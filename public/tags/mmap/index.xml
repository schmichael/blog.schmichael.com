<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mmap on </title>
    <link>/tags/mmap/</link>
    <description>Recent content in Mmap on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 06 Sep 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/mmap/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MemoryMapFile Convenience Class for Python</title>
      <link>/2011/09/05/memorymapfile-convenience-class-for-python/</link>
      <pubDate>Tue, 06 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/05/memorymapfile-convenience-class-for-python/</guid>
      <description>&lt;p&gt;My &lt;a href=&#34;/2011/05/15/sharing-python-data-between-processes-using-mmap/&#34;&gt;obsession&lt;/a&gt; with &lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap&lt;/a&gt; hasn&amp;#8217;t died, but while &lt;a href=&#34;http://docs.python.org/library/mmap&#34;&gt;Python&amp;#8217;s mmap module&lt;/a&gt; is a wonderful low level library it&amp;#8217;s a bit hard for a newcomer to use properly.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve started toying with a convenience wrapper class for &lt;code&gt;mmap.mmap&lt;/code&gt; (at least the Unix version):&lt;/p&gt;

&lt;p&gt;My original goal was to automatically &lt;a href=&#34;http://docs.python.org/library/mmap#mmap.resize&#34;&gt;grow&lt;/a&gt; the mmap whenever the user attempts to write beyond the current size of the mmap file, but that&amp;#8217;s going to take carefully wrapping quite a few methods (&lt;code&gt;write&lt;/code&gt;, &lt;code&gt;__setitem__&lt;/code&gt;, and maybe get/read methods too).&lt;/p&gt;

&lt;p&gt;If it becomes useful, I may use it in [mmstats][5].&lt;/p&gt;

&lt;p&gt;Feedback welcome!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Discovered the hard way (segfaults) that resizing mmaps is tricky: the region can be moved but data will be copied. However, any existing pointers (from ctypes.&lt;type&gt;.from_buffer in my case) will now point to freed memory and segfault upon use.&lt;/p&gt;

&lt;p&gt;tl;dr &amp;#8211; If at all possible, precompute the size of your mmap before using it.&lt;/p&gt;

&lt;p&gt;[5]: &lt;a href=&#34;https://github.com/schmichael/mmstats&#34;&gt;https://github.com/schmichael/mmstats&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sharing Python data between processes using mmap</title>
      <link>/2011/05/15/sharing-python-data-between-processes-using-mmap/</link>
      <pubDate>Mon, 16 May 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/05/15/sharing-python-data-between-processes-using-mmap/</guid>
      <description>&lt;p&gt;I&amp;#8217;ve been toying with an idea of exposing statistics for a Python application via shared memory to keep the performance impact on the application as low as possible. The goal being an application could passively expose a number of metrics that could either be periodically polled via &lt;a href=&#34;http://munin-monitoring.org/&#34;&gt;munin&lt;/a&gt;/&lt;a href=&#34;http://www.icinga.org/&#34;&gt;Icinga&lt;/a&gt;/etc plugins or interactive tools when diagnosing issues on a system.&lt;/p&gt;

&lt;p&gt;But first things first: I need to put data into &lt;a href=&#34;http://en.wikipedia.org/wiki/Shared_memory&#34;&gt;shared memory&lt;/a&gt; from Python. &lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap&lt;/a&gt; is an excellent widely-implemented POSIX system call for creating a shared memory space backed by an on-disk file.&lt;/p&gt;

&lt;p&gt;Usually in the UNIX world you have 2 ways of accessing/manipulating data: memory addresses or streams (files). Manipulating data via memory addresses means &lt;a href=&#34;http://en.wikipedia.org/wiki/Pointer_%28computing%29&#34;&gt;pointers&lt;/a&gt;, offsets, &lt;a href=&#34;http://en.wikipedia.org/wiki/Malloc&#34;&gt;malloc/free&lt;/a&gt;, etc. Stream interfaces manipulate data via &lt;a href=&#34;http://en.wikipedia.org/wiki/System_call&#34;&gt;read/write/seek system calls&lt;/a&gt; for files and &lt;a href=&#34;http://en.wikipedia.org/wiki/Berkeley_sockets&#34;&gt;send/recv/etc for sockets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;mmap gives you both interfaces. A memory mapped file can be manipulated via read/write/seek or by directly accessing its mapped memory region. The advantage of the latter is that this memory region is in userspace &amp;#8212; meaning you can manipulate a file without incurring the overhead of write system calls for every manipulation.&lt;/p&gt;

&lt;p&gt;Anyway, enough exposition, let&amp;#8217;s see some code. &lt;small&gt;(Despite mmap&amp;#8217;s nice featureset, I&amp;#8217;m only using it as a simple memory sharing mechanism anyway.)&lt;/small&gt; The following code shares a tiny bit of data between 2 Python processes using the excellent &lt;a href=&#34;http://docs.python.org/library/mmap&#34;&gt;mmap module in the stdlib&lt;/a&gt;. &lt;code&gt;a.py&lt;/code&gt; writes to the memory mapped region, and &lt;code&gt;b.py&lt;/code&gt; reads the data out. [ctypes][10] allows for an easy way to create values in a memory mapped region and manipulate them like &amp;#8220;normal&amp;#8221; Python objects.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;These code samples were written using Python 2.7 on Linux. They should work fine on any POSIX system, but Windows users will have to change the mmap calls to match the Windows API.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a.py&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;#!/usr/bin/env python
import ctypes
import mmap
import os
import struct


def main():
    # Create new empty file to back memory map on disk
    fd = os.open(&#39;/tmp/mmaptest&#39;, os.O_CREAT | os.O_TRUNC | os.O_RDWR)

    # Zero out the file to insure it&#39;s the right size
    assert os.write(fd, &#39;\x00&#39; * mmap.PAGESIZE) == mmap.PAGESIZE

    # Create the mmap instace with the following params:
    # fd: File descriptor which backs the mapping or -1 for anonymous mapping
    # length: Must in multiples of PAGESIZE (usually 4 KB)
    # flags: MAP_SHARED means other processes can share this mmap
    # prot: PROT_WRITE means this process can write to this mmap
    buf = mmap.mmap(fd, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_WRITE)

    # Now create an int in the memory mapping
    i = ctypes.c_int.from_buffer(buf)

    # Set a value
    i.value = 10

    # And manipulate it for kicks
    i.value += 1
    
    assert i.value == 11

    # Before we create a new value, we need to find the offset of the next free
    # memory address within the mmap
    offset = struct.calcsize(i._type_)

    # The offset should be uninitialized (&#39;\x00&#39;)
    assert buf[offset] == &#39;\x00&#39;

    # Now ceate a string containing &#39;foo&#39; by first creating a c_char array
    s_type = ctypes.c_char * len(&#39;foo&#39;)

    # Now create the ctypes instance
    s = s_type.from_buffer(buf, offset)

    # And finally set it
    s.raw = &#39;foo&#39;

    print &#39;First 10 bytes of memory mapping: %r&#39; % buf[:10]
    raw_input(&#39;Now run b.py and press ENTER&#39;)

    print
    print &#39;Changing i&#39;
    i.value *= i.value

    print &#39;Changing s&#39;
    s.raw = &#39;bar&#39;

    new_i = raw_input(&#39;Enter a new value for i: &#39;)
    i.value = int(new_i)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;b.py&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;import mmap
import os
import struct
import time

def main():
    # Open the file for reading
    fd = os.open(&#39;/tmp/mmaptest&#39;, os.O_RDONLY)

    # Memory map the file
    buf = mmap.mmap(fd, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_READ)

    i = None
    s = None

    while 1:
        new_i, = struct.unpack(&#39;i&#39;, buf[:4])
        new_s, = struct.unpack(&#39;3s&#39;, buf[4:7])

        if i != new_i or s != new_s:
            print &#39;i: %s =&gt; %d&#39; % (i, new_i)
            print &#39;s: %s =&gt; %s&#39; % (s, new_s)
            print &#39;Press Ctrl-C to exit&#39;
            i = new_i
            s = new_s

        time.sleep(1)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;(Note that I cruelly don&amp;#8217;t clean up /tmp/mmaptest after the scripts finished. Consider it a 4KB tax for anyone who runs arbitrary code they found on the Internet without reading it first.)&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;[10]: &lt;a href=&#34;http://docs.python.org/library/ctypes&#34;&gt;http://docs.python.org/library/ctypes&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>