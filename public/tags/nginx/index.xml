<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on </title>
    <link>/tags/nginx/</link>
    <description>Recent content in Nginx on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 25 Jan 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Deploying Python behind Nginx Talk Slides</title>
      <link>/2011/01/25/deploying-python-behind-nginx-talk-slides/</link>
      <pubDate>Tue, 25 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/01/25/deploying-python-behind-nginx-talk-slides/</guid>
      <description>&lt;p&gt;I gave a talk on deploying Python WSGI apps behind &lt;a href=&#34;http://wiki.nginx.org/&#34;&gt;nginx&lt;/a&gt; at the &lt;a href=&#34;http://wiki.python.org/moin/PortlandPythonUserGroup&#34;&gt;Portland Python User Group&lt;/a&gt; meeting on January 11th and finally got around to publishing the slides: &lt;a href=&#34;https://docs.google.com/present/edit?id=0Ab7GDIugV1qCZGR6c3d6YnJfMTA1aGRtZmJxYzI&amp;amp;hl=en&#34;&gt;schmingx&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I should mention &lt;a href=&#34;http://discorporate.us/jek/&#34;&gt;Jason Kirtland&lt;/a&gt; informed me after the meeting that &lt;a href=&#34;http://www.fastcgi.com/devkit/doc/fcgi-spec.html&#34;&gt;FastCGI&lt;/a&gt; supports [persistent connections (and a host of other features)][6] between a load balancer and backend app servers.&lt;/p&gt;

&lt;p&gt;[6]: &lt;a href=&#34;http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S3.5&#34;&gt;http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S3.5&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Complete Noobs Guide to Hacking Nginx</title>
      <link>/2010/12/28/noobs-guide-to-hacking-nginx/</link>
      <pubDate>Wed, 29 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/12/28/noobs-guide-to-hacking-nginx/</guid>
      <description>&lt;p&gt;At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``&lt;/p&gt;

&lt;p&gt;Success! Now create a patch &lt;code&gt;diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch&lt;/code&gt; and &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000605.html&#34;&gt;post it to the nginx-devel mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Second Pass: Fixing WebDAV&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A positive &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000606.html&#34;&gt;reply from Maxim Dounin to my patch&lt;/a&gt;! I don&amp;rsquo;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&amp;rsquo;t break official modules.&lt;/p&gt;

&lt;p&gt;This time around I wanted to work locally, so I installed nginx with the following configuration:&lt;/p&gt;

&lt;p&gt;```At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``&lt;/p&gt;

&lt;p&gt;Success! Now create a patch &lt;code&gt;diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch&lt;/code&gt; and &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000605.html&#34;&gt;post it to the nginx-devel mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Second Pass: Fixing WebDAV&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A positive &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000606.html&#34;&gt;reply from Maxim Dounin to my patch&lt;/a&gt;! I don&amp;rsquo;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&amp;rsquo;t break official modules.&lt;/p&gt;

&lt;p&gt;This time around I wanted to work locally, so I installed nginx with the following configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.&lt;/p&gt;

&lt;p&gt;The importance of being able to attach a debugger became clear as soon as I tested &lt;a href=&#34;http://wiki.nginx.org/HttpDavModule&#34;&gt;dav support (with their standard config)&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
My patch was causing a segfault in the dav module that killed nginx&#39;s worker process. Bumping up my error logging to `debug` level didn&#39;t give me many clues:
  
`````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

``` 

Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

``` 

Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My patch was causing a segfault in the dav module that killed nginx&amp;rsquo;s worker process. Bumping up my error logging to &lt;code&gt;debug&lt;/code&gt; level didn&amp;rsquo;t give me many clues:&lt;/p&gt;

&lt;p&gt;`````&lt;/p&gt;

&lt;p&gt;Time to break out the debugger! While I&amp;rsquo;ve used &lt;code&gt;gdb --pid&lt;/code&gt; to attach to running processes before, I&amp;rsquo;d just installed Eclipse to work on some Java code and wondered if it might make debugging a bit easier.&lt;/p&gt;

&lt;p&gt;After installing plugins for C/C++, Autotools, and GDB, I could easily import nginx by creating a &amp;ldquo;New Makefile project with existing code&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-02-import-existing.png&#34; alt=&#34;Import existing code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now create a new Debug Configuration:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-03-debug-conf.png&#34; alt=&#34;Debug Configuration&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt; on Linux systems (at least Ubuntu):&lt;/em&gt; by default PTRACE is disabled in the kernel. Just flip the 1 to 0 in &lt;code&gt;/etc/sysctl.d/10-ptrace.conf&lt;/code&gt; and run &lt;code&gt;sudo sysctl -p /etc/sysctl.d/10-ptrace.conf&lt;/code&gt; to allow PTRACE.&lt;/p&gt;

&lt;p&gt;Finally click &amp;ldquo;Debug&amp;rdquo; and select the nginx &lt;em&gt;worker&lt;/em&gt; process from your process list:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-04-select-process.png&#34; alt=&#34;Select Process&#34; /&gt;&lt;/p&gt;

&lt;p&gt;By default GDB will pause the process it attaches to, so make sure to click the Resume button (or press F8) to allow nginx to continue serving requests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crashing nginx&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now cause the segfault by running our curl command &lt;code&gt;curl -v -X PUT http://localhost:8888/foo&lt;/code&gt;. This time curl won&amp;rsquo;t return because gdb/Eclipse caught the segfault in the nginx child process, leaving the socket to curl open. A quick peek in Eclipse shows us exactly where the segfault occurs:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-05-debugging.png&#34; alt=&#34;Debugging in Eclipse&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Eclipse makes it quick and easy to interactively inspect the variables. Doing that I discovered the culprit was the src variable being uninitialized. Bouncing up the stack once you can see dav&amp;rsquo;s put handler expects to be given a temporary file (&lt;code&gt;&amp;amp;#038;r-&amp;gt;request_body-&amp;gt;temp_file-&amp;gt;file.name&lt;/code&gt;) full of PUT data (of which we sent none), and it copies that to the destination file (&lt;code&gt;path&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Bounce up the stack again to &lt;code&gt;ngx_http_read_client_request_body&lt;/code&gt; and you can see this relevant code:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;headers_in.content_length_n &amp;lt; 0) {&lt;/pre&gt;

&lt;p&gt;nginx&amp;rsquo;s core HTTP module short circuits a bit when there&amp;rsquo;s no Content-Length specified. It skips the temp file creation because there&amp;rsquo;s no data to put into the temp file!&lt;/p&gt;

&lt;p&gt;So we have our problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The dav module put handler expects a temp file containing the data to be saved.&lt;/li&gt;
&lt;li&gt;The http module doesn&amp;rsquo;t create a temp file when there&amp;rsquo;s no body data.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The 2 solutions I can think of are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Always create a temp file, even if it&amp;rsquo;s empty.&lt;/li&gt;
&lt;li&gt;Add a special case to the dav module&amp;rsquo;s put handler for when the temp file doesn&amp;rsquo;t exist.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I really don&amp;rsquo;t want to hack the core http module just to make a sub-module happy. It &lt;em&gt;makes sense&lt;/em&gt; that no temporary file exists when there&amp;rsquo;s no body data. Sub-modules shouldn&amp;rsquo;t be lazy and expect it to exist. So I decided to try #2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Fix&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can see my &lt;a href=&#34;https://github.com/schmichael/nginx/commit/c6051556460561bac4b0931fd9436e37b84925a3&#34;&gt;implementation of solution #2 on GitHub&lt;/a&gt;. Simply put, if the temp file exists, follow the existing logic. If the temp file does not exist we have a PUT with an empty body: use nginx&amp;rsquo;s open wrapper to do a create or truncate (&lt;code&gt;O_CREAT|O_TRUNC&lt;/code&gt;) on the destination file (since an empty PUT should create an empty file).&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know if this is the best solution or even a correct one, but it appears to work and was a fun journey arriving at it. You can [follow the discussion on the mailing list][20].&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Updated to switch from bitbucket to github.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;[20]: &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000609.html&#34;&gt;http://nginx.org/pipermail/nginx-devel/2010-December/000609.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web Server Shootout Talk Accepted at OS Bridge Conference</title>
      <link>/2009/04/26/web-server-shootout-talk-accepted-at-os-bridge-conference/</link>
      <pubDate>Sun, 26 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/04/26/web-server-shootout-talk-accepted-at-os-bridge-conference/</guid>
      <description>&lt;p&gt;My talk, &lt;a href=&#34;http://opensourcebridge.org/sessions/119&#34;&gt;Web Server Shootout&lt;/a&gt;, was accepted by the Open Source Bridge Conference! I&amp;#8217;m terribly excited, but also nervous because there&amp;#8217;s a lot I need to do between now and the conference. Expect regular updates on how my talk is progressing (always tagged with osbridge [feed]).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://opensourcebridge.org/2009/04/open-source-bridge-conference-confirmed-speakers/&#34;&gt;full list of sessions is up&lt;/a&gt; (or &lt;a href=&#34;http://opensourcebridge.org/events/2009/sessions&#34;&gt;here&lt;/a&gt;), and I&amp;#8217;m very excited just to be attending the conference. Congratulations to all of the speakers!&lt;/p&gt;

&lt;p&gt;Some of the sessions I&amp;#8217;m particularly excited to attend are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://opensourcebridge.org/sessions/20&#34;&gt;An Introduction to Machine Learning by John Melesky&lt;/a&gt; &amp;#8211; A Portland Python User Group regular and really smart guy in general. Looking forward to getting my feet wet with machine learning.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://opensourcebridge.org/sessions/100&#34;&gt;Drop ACID and think about data by Bob Ippolito&lt;/a&gt; &amp;#8211; I think the Portland Python crew that went to Pycon helped convince Bob to bring his presentation to OS Bridge, and I&amp;#8217;m glad they did! I work with non-relational databases everyday, but I still design my apps with a relational data model in mind. This should be interesting.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://opensourcebridge.org/sessions/33&#34;&gt;The Linux Kernel Development model by Greg Kroah-Hartman&lt;/a&gt; &amp;#8211; Its &lt;a href=&#34;http://en.wikipedia.org/wiki/Greg_Kroah-Hartman&#34;&gt;Greg KH&lt;/a&gt;! Come on!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://opensourcebridge.org/sessions/95&#34;&gt;How Idealist.org uses technology to change the world by Michel Pelletier&lt;/a&gt; &amp;#8211; Another Portland Pythoneer and really smart guy. Eager to here more about open source at work in an organization. Its always fun to watch Michel present anyway.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://opensourcebridge.org/sessions/36&#34;&gt;Web Testing with Windmill by Mikeal Rogers&lt;/a&gt; &amp;#8211; Hardly a day goes by that I don&amp;#8217;t tell myself I&amp;#8217;m going to improve my test coverage and skills. Windmill looks like an excellent testing tool to help me accomplish that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are many many more sessions I&amp;#8217;m excited about, but I&amp;#8217;m too sick of copying and pasting to mention anymore right now.&lt;/p&gt;

&lt;p&gt;So [sign up to attend the Open Source Bridge Conference in Portland, OR this June!][10]&lt;/p&gt;

&lt;p&gt;[10]: &lt;a href=&#34;http://opensourcebridge.org/attend/&#34;&gt;http://opensourcebridge.org/attend/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web Server Quandary</title>
      <link>/2008/12/27/web-server-quandary/</link>
      <pubDate>Sat, 27 Dec 2008 00:00:00 +0000</pubDate>
      
      <guid>/2008/12/27/web-server-quandary/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://httpd.apache.org/&#34;&gt;Apache&lt;/a&gt; was probably the first Linux application I learned how to configure. However, I&amp;#8217;ve gotten a bit frustrated with it recently&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A memory leak.&lt;/em&gt; Apache is eating up memory so quickly that I need to restart it every couple days or risk my entire server grinding to a halt as it starts swapping wildly. I&amp;#8217;ve poured over log files and &lt;code&gt;pmap&lt;/code&gt; output, but I still can&amp;#8217;t figure out where the problem lies. Curse you monolithic in-process architecture!&lt;/p&gt;

&lt;p&gt;Actually I know what my problem is, I&amp;#8217;m running a mess of modules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssl&lt;/code&gt; &amp;#8211; 2 certificates on 2 ports&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php5&lt;/code&gt; &amp;#8211; blerg, who doesn&amp;#8217;t have to run this?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;suphp&lt;/code&gt; &amp;#8211; I suspect this is my problem, but I can&amp;#8217;t prove it. A client&amp;#8217;s 3rd party web application &lt;em&gt;requires&lt;/em&gt; it, but I think its easily replaceable with FastCGI.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi&lt;/code&gt; &amp;#8211; No complaints. Python apps are out-of-process thankfully.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy&lt;/code&gt; &amp;#8211; Again no complaints. Can&amp;#8217;t imagine how this module could cause any problems except it does proxy some large (multi-megabyte, not huge) POSTs at times. I can&amp;#8217;t imagine a memory leak could slip into this module without a lot of people noticing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Solution A: Apache+FastCGI&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I love the idea of putting each web application in its own process and letting Apache just act as an HTTP router. FastCGI seems to have all the features I need, and I&amp;#8217;m not really worried about the CPU overhead incurred by IPC.&lt;/p&gt;

&lt;p&gt;However, there are 2 competing FastCGI modules for Apache, and I have no idea what to choose. Anecdotally the official &lt;a href=&#34;http://www.fastcgi.com/drupal/node/3&#34;&gt;mod_fastcgi&lt;/a&gt; is buggy and &lt;a href=&#34;http://www.fastcgi.com/drupal/node/2&#34;&gt;fastcgi.com is a spam infested wasteland&lt;/a&gt;. However, I&amp;#8217;ve found no authoritative source saying: &lt;em&gt;&amp;#8220;fastcgi is dead, long live &lt;a href=&#34;http://fastcgi.coremail.cn/&#34;&gt;fcgid&lt;/a&gt;!&amp;#8221;&lt;/em&gt; (Lame excuse, I know.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution B: &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;Lighttpd&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I know Lighty is the darling of Rails sites, but whenever I stop by its site I&amp;#8217;m greeted with a list of recently fixed &lt;a href=&#34;http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=lighttpd&#34;&gt;security bugs&lt;/a&gt;, and now it seems as though &lt;a href=&#34;http://blog.lighttpd.net/articles/2008/12/02/a-little-heads-up&#34;&gt;they&amp;#8217;re rewriting the core&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;I&amp;#8217;m sure Lighty is a high quality intelligently engineered project, but it seems to be the definition of immature. Not necessarily bad (in fact it usually means its progressing quickly!), but perhaps not as reliable as good old workhorses like Apache.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution C: &lt;a href=&#34;http://www.cherokee-project.com/&#34;&gt;Cherokee&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve been following Cherokee for some time now and running it locally on my workstation. I &lt;em&gt;love&lt;/em&gt; the web interface. I&amp;#8217;m usually a very anti-webmin, pro-vim kind of guy, but I&amp;#8217;m sick of editing Apache&amp;#8217;s config files. I do it about once a month and therefore it always takes lots of double-checking the docs. I don&amp;#8217;t know why, but its configuration has just never felt natural to me.&lt;/p&gt;

&lt;p&gt;However, the lead Cherokee developer&amp;#8217;s bravado is by the most off-putting aspect of the project. &lt;a href=&#34;http://lists.octality.com/pipermail/cherokee/2008-December/009437.html&#34;&gt;He mocks modwsgi&lt;/a&gt; and posts simplistic benchmarks showing Cherokee to be the fastest web server, but meanwhile Cherokee churns out numerous bug patch releases in-between feature releases and has yet to reach 1.0 status.&lt;/p&gt;

&lt;p&gt;It seems like an excellent project technically, but I&amp;#8217;m afraid there will be negative consequences for the lead developers hubris. &lt;small&gt;(I&amp;#8217;m not meaning to insult the guy. He&amp;#8217;s probably a far better hacker than I&amp;#8217;ll ever be. Self-promotion just makes me uncomfortable.)&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution D: [nginx][10]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;#8217;t know much about nginx except that it works. Basically all I&amp;#8217;ve heard about it is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It works.&lt;/li&gt;
&lt;li&gt;Its fast. &lt;em&gt;Really&lt;/em&gt; fast.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While &amp;#8220;working&amp;#8221; is definitely my primary objective, nginx seems a bit bare bones for me. I just don&amp;#8217;t think I&amp;#8217;m the target demographic. I&amp;#8217;d kind of like for my web server to handle spawning and kill of FastCGI processes.&lt;/p&gt;

&lt;p&gt;nginx feels like git to me. Those who know it: use it and love it. Those who don&amp;#8217;t: stand in fear and awe of its unbridled power.&lt;/p&gt;

&lt;p&gt;&amp;#8230;or maybe its just a nice simple barebones HTTP server&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusions?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I think &lt;strong&gt;Solution A: FastCGI&lt;/strong&gt; is the most sensible. Apache has always served me well, and the memory leak is most likely due to that shoddy suphp module.&lt;/p&gt;

&lt;p&gt;Moving my web applications to FastCGI is also the best way to prepare to move to one of these 2nd generation web servers.&lt;/p&gt;

&lt;p&gt;However, I&amp;#8217;m getting kind of sick of Apache, and the ambiguousness of which FastCGI solution to choose is fairly annoying.&lt;/p&gt;

&lt;p&gt;So dear lazyweb, for your everyday web developer consultant looking to run a bunch of PHP and Python web applications, what HTTP server stack should I use? (Debian Lenny packages are a plus.)&lt;/p&gt;

&lt;p&gt;[10]: &lt;a href=&#34;http://nginx.net/&#34;&gt;http://nginx.net/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>