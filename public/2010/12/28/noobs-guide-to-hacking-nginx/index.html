<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>A Complete Noobs Guide to Hacking Nginx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.15" />
  <link href="" rel="alternate" type="application/rss+xml" title="schmichael&#39;s blog" />
  <link href="https://blog.schmichael.com//css/bootstrap.min.css" rel="stylesheet">
  <link href="https://blog.schmichael.com//css/hc.css" rel="stylesheet">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  
    
    </head>
    <body>
<div class="nav-toggle"><i class="fa fa-bars fa-2x"></i> Herring Cove </div>
      <div id = "wrapper">


<div class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="https://blog.schmichael.com//"><p class="navbar-brand">schmichael&#39;s blog</p></a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
					
					
					<li><a href="https://blog.schmichael.com//blog/">Blog </a></li>
					
					<li><a href="https://blog.schmichael.com//about-me/">About </a></li>
					
					<li><a href="https://blog.schmichael.com//">Home </a></li>
					
          </ul>
        </div>
      </div>
    </div>



       
       <div id="sidebar-wrapper">
        <ul class="sidebar-nav">
					<img src="" />
          <li class="sidebar-brand"><a href="https://blog.schmichael.com//"><h1 class="brand">schmichael&#39;s blog</h1></a><h3></h3></li>
          <hr />
					
						<li><a href="https://blog.schmichael.com//blog/">Blog </a></li>
					
						<li><a href="https://blog.schmichael.com//about-me/">About </a></li>
					
						<li><a href="https://blog.schmichael.com//">Home </a></li>
					
          <hr />
          <div id="social-wrapper">
           
           
           
           
         </div>
       </ul>
     </div>



     <div class="container">


  <div id="article">
   <div class="article-title">A Complete Noobs Guide to Hacking Nginx</div>
   <p class="meta"><small>&nbsp;<i class="fa fa-calendar-o"></i> 2010-12-29</small></p> <hr/>
   <div class="post">
     <p>At <a href="http://urbanairship.com">Urban Airship</a> our <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services">RESTful HTTP API</a> uses PUT requests for, among other things, <a href="http://urbanairship.com/docs/push.html#registration">registering a device</a>. Since the application registering the device is the HTTP Basic Auth username, there&#8217;s often no body (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2">entity body</a> in HTTP parlance). Unfortunately <a href="http://wiki.nginx.org">nginx</a> (as of 0.8.54, and I believe 0.9.3) doesn&#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the <a href="http://wiki.nginx.org/HttpChunkinModule">chunkin</a> module adds Transfer-Encoding: chunked support, it doesn&#8217;t fix the empty PUT problem since HTTP requests without bodies don&#8217;t require Content-Length nor Transfer-Encoding headers.</p>

<p>So let&#8217;s hack nginx shall we?</p>

<p>I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&#8217;t come easily to me. To make matters worse, as far as I can tell there&#8217;s no official public source repository (<a href="https://github.com/git-mirror/nginx">but there&#8217;s a mirror</a>) and it seems to be mainly developed by the creator, <a href="http://sysoev.ru/en/">Igor Sysoev</a>. At least the code looks clean.</p>

<p><strong>First Pass</strong></p>

<p>I had <a href="http://nginx.org/download/nginx-0.8.54.tar.gz">nginx-0.8.54.tar.gz</a> handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:</p>

<blockquote>
<p>client sent PUT method without &#8220;Content-Length&#8221; header while reading client request headers, client: &#8230;, server: , request: &#8220;PUT / HTTP/1.1&#8221; &#8230;</p>
</blockquote>

<p>So let&#8217;s use <a href="http://betterthangrep.com/">ack</a> to find it:</p>

<p><img src="http://schmichael.com/files/nginx-01-ack.png" alt="ack-grep 'client sent .* method without'" title="ack-grep 'client sent .* method without'" /></p>

<p>A quick <code>vim +1532 src/http/ngx_http_request.c</code> later and we&#8217;re looking at the problem:</p>

<pre lang="c">if (r->method &#038; NGX_HTTP_PUT &#038;&#038; r->headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  "client sent %V method without \"Content-Length\" header",
                  &#038;r->method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }</pre>

<p>This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (<code>make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart</code>), and test:</p>

<p>``At <a href="http://urbanairship.com">Urban Airship</a> our <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services">RESTful HTTP API</a> uses PUT requests for, among other things, <a href="http://urbanairship.com/docs/push.html#registration">registering a device</a>. Since the application registering the device is the HTTP Basic Auth username, there&#8217;s often no body (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2">entity body</a> in HTTP parlance). Unfortunately <a href="http://wiki.nginx.org">nginx</a> (as of 0.8.54, and I believe 0.9.3) doesn&#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the <a href="http://wiki.nginx.org/HttpChunkinModule">chunkin</a> module adds Transfer-Encoding: chunked support, it doesn&#8217;t fix the empty PUT problem since HTTP requests without bodies don&#8217;t require Content-Length nor Transfer-Encoding headers.</p>

<p>So let&#8217;s hack nginx shall we?</p>

<p>I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&#8217;t come easily to me. To make matters worse, as far as I can tell there&#8217;s no official public source repository (<a href="https://github.com/git-mirror/nginx">but there&#8217;s a mirror</a>) and it seems to be mainly developed by the creator, <a href="http://sysoev.ru/en/">Igor Sysoev</a>. At least the code looks clean.</p>

<p><strong>First Pass</strong></p>

<p>I had <a href="http://nginx.org/download/nginx-0.8.54.tar.gz">nginx-0.8.54.tar.gz</a> handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:</p>

<blockquote>
<p>client sent PUT method without &#8220;Content-Length&#8221; header while reading client request headers, client: &#8230;, server: , request: &#8220;PUT / HTTP/1.1&#8221; &#8230;</p>
</blockquote>

<p>So let&#8217;s use <a href="http://betterthangrep.com/">ack</a> to find it:</p>

<p><img src="http://schmichael.com/files/nginx-01-ack.png" alt="ack-grep 'client sent .* method without'" title="ack-grep 'client sent .* method without'" /></p>

<p>A quick <code>vim +1532 src/http/ngx_http_request.c</code> later and we&#8217;re looking at the problem:</p>

<pre lang="c">if (r->method &#038; NGX_HTTP_PUT &#038;&#038; r->headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  "client sent %V method without \"Content-Length\" header",
                  &#038;r->method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }</pre>

<p>This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (<code>make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart</code>), and test:</p>

<p>``</p>

<p>Success! Now create a patch <code>diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch</code> and <a href="http://nginx.org/pipermail/nginx-devel/2010-December/000605.html">post it to the nginx-devel mailing list</a>.</p>

<p>Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.</p>

<p><strong>Second Pass: Fixing WebDAV</strong></p>

<p>A positive <a href="http://nginx.org/pipermail/nginx-devel/2010-December/000606.html">reply from Maxim Dounin to my patch</a>! I don&rsquo;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&rsquo;t break official modules.</p>

<p>This time around I wanted to work locally, so I installed nginx with the following configuration:</p>

<p>```At <a href="http://urbanairship.com">Urban Airship</a> our <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services">RESTful HTTP API</a> uses PUT requests for, among other things, <a href="http://urbanairship.com/docs/push.html#registration">registering a device</a>. Since the application registering the device is the HTTP Basic Auth username, there&#8217;s often no body (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2">entity body</a> in HTTP parlance). Unfortunately <a href="http://wiki.nginx.org">nginx</a> (as of 0.8.54, and I believe 0.9.3) doesn&#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the <a href="http://wiki.nginx.org/HttpChunkinModule">chunkin</a> module adds Transfer-Encoding: chunked support, it doesn&#8217;t fix the empty PUT problem since HTTP requests without bodies don&#8217;t require Content-Length nor Transfer-Encoding headers.</p>

<p>So let&#8217;s hack nginx shall we?</p>

<p>I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&#8217;t come easily to me. To make matters worse, as far as I can tell there&#8217;s no official public source repository (<a href="https://github.com/git-mirror/nginx">but there&#8217;s a mirror</a>) and it seems to be mainly developed by the creator, <a href="http://sysoev.ru/en/">Igor Sysoev</a>. At least the code looks clean.</p>

<p><strong>First Pass</strong></p>

<p>I had <a href="http://nginx.org/download/nginx-0.8.54.tar.gz">nginx-0.8.54.tar.gz</a> handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:</p>

<blockquote>
<p>client sent PUT method without &#8220;Content-Length&#8221; header while reading client request headers, client: &#8230;, server: , request: &#8220;PUT / HTTP/1.1&#8221; &#8230;</p>
</blockquote>

<p>So let&#8217;s use <a href="http://betterthangrep.com/">ack</a> to find it:</p>

<p><img src="http://schmichael.com/files/nginx-01-ack.png" alt="ack-grep 'client sent .* method without'" title="ack-grep 'client sent .* method without'" /></p>

<p>A quick <code>vim +1532 src/http/ngx_http_request.c</code> later and we&#8217;re looking at the problem:</p>

<pre lang="c">if (r->method &#038; NGX_HTTP_PUT &#038;&#038; r->headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  "client sent %V method without \"Content-Length\" header",
                  &#038;r->method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }</pre>

<p>This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (<code>make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart</code>), and test:</p>

<p>``At <a href="http://urbanairship.com">Urban Airship</a> our <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services">RESTful HTTP API</a> uses PUT requests for, among other things, <a href="http://urbanairship.com/docs/push.html#registration">registering a device</a>. Since the application registering the device is the HTTP Basic Auth username, there&#8217;s often no body (<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2">entity body</a> in HTTP parlance). Unfortunately <a href="http://wiki.nginx.org">nginx</a> (as of 0.8.54, and I believe 0.9.3) doesn&#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the <a href="http://wiki.nginx.org/HttpChunkinModule">chunkin</a> module adds Transfer-Encoding: chunked support, it doesn&#8217;t fix the empty PUT problem since HTTP requests without bodies don&#8217;t require Content-Length nor Transfer-Encoding headers.</p>

<p>So let&#8217;s hack nginx shall we?</p>

<p>I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&#8217;t come easily to me. To make matters worse, as far as I can tell there&#8217;s no official public source repository (<a href="https://github.com/git-mirror/nginx">but there&#8217;s a mirror</a>) and it seems to be mainly developed by the creator, <a href="http://sysoev.ru/en/">Igor Sysoev</a>. At least the code looks clean.</p>

<p><strong>First Pass</strong></p>

<p>I had <a href="http://nginx.org/download/nginx-0.8.54.tar.gz">nginx-0.8.54.tar.gz</a> handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:</p>

<blockquote>
<p>client sent PUT method without &#8220;Content-Length&#8221; header while reading client request headers, client: &#8230;, server: , request: &#8220;PUT / HTTP/1.1&#8221; &#8230;</p>
</blockquote>

<p>So let&#8217;s use <a href="http://betterthangrep.com/">ack</a> to find it:</p>

<p><img src="http://schmichael.com/files/nginx-01-ack.png" alt="ack-grep 'client sent .* method without'" title="ack-grep 'client sent .* method without'" /></p>

<p>A quick <code>vim +1532 src/http/ngx_http_request.c</code> later and we&#8217;re looking at the problem:</p>

<pre lang="c">if (r->method &#038; NGX_HTTP_PUT &#038;&#038; r->headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                  "client sent %V method without \"Content-Length\" header",
                  &#038;r->method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }</pre>

<p>This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (<code>make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart</code>), and test:</p>

<p>``</p>

<p>Success! Now create a patch <code>diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch</code> and <a href="http://nginx.org/pipermail/nginx-devel/2010-December/000605.html">post it to the nginx-devel mailing list</a>.</p>

<p>Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.</p>

<p><strong>Second Pass: Fixing WebDAV</strong></p>

<p>A positive <a href="http://nginx.org/pipermail/nginx-devel/2010-December/000606.html">reply from Maxim Dounin to my patch</a>! I don&rsquo;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&rsquo;t break official modules.</p>

<p>This time around I wanted to work locally, so I installed nginx with the following configuration:</p>

<pre><code>
Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don't use WebDAV though, but if I want this patch accepted I better make sure it doesn't break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don't use WebDAV though, but if I want this patch accepted I better make sure it doesn't break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

</code></pre>

<p>Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.</p>

<p>The importance of being able to attach a debugger became clear as soon as I tested <a href="http://wiki.nginx.org/HttpDavModule">dav support (with their standard config)</a>:</p>

<pre><code>
My patch was causing a segfault in the dav module that killed nginx's worker process. Bumping up my error logging to `debug` level didn't give me many clues:
  
`````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don't use WebDAV though, but if I want this patch accepted I better make sure it doesn't break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don't use WebDAV though, but if I want this patch accepted I better make sure it doesn't break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

``` 

Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don't use WebDAV though, but if I want this patch accepted I better make sure it doesn't break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository ([but there&amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&gt; client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230; 

So let&amp;#8217;s use [ack][10] to find it:

![ack-grep 'client sent .* method without'][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;#8217;re looking at the problem:

&lt;pre lang=&quot;c&quot;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &quot;client sent %V method without \&quot;Content-Length\&quot; header&quot;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;#038;&amp;#038; sudo make install &amp;#038;&amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don't use WebDAV though, but if I want this patch accepted I better make sure it doesn't break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

``` 

Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
</code></pre>

<p>My patch was causing a segfault in the dav module that killed nginx&rsquo;s worker process. Bumping up my error logging to <code>debug</code> level didn&rsquo;t give me many clues:</p>

<p>`````</p>

<p>Time to break out the debugger! While I&rsquo;ve used <code>gdb --pid</code> to attach to running processes before, I&rsquo;d just installed Eclipse to work on some Java code and wondered if it might make debugging a bit easier.</p>

<p>After installing plugins for C/C++, Autotools, and GDB, I could easily import nginx by creating a &ldquo;New Makefile project with existing code&rdquo;:</p>

<p><img src="http://schmichael.com/files/nginx-02-import-existing.png" alt="Import existing code" /></p>

<p>Now create a new Debug Configuration:</p>

<p><img src="http://schmichael.com/files/nginx-03-debug-conf.png" alt="Debug Configuration" /></p>

<p><em><strong>Note</strong> on Linux systems (at least Ubuntu):</em> by default PTRACE is disabled in the kernel. Just flip the 1 to 0 in <code>/etc/sysctl.d/10-ptrace.conf</code> and run <code>sudo sysctl -p /etc/sysctl.d/10-ptrace.conf</code> to allow PTRACE.</p>

<p>Finally click &ldquo;Debug&rdquo; and select the nginx <em>worker</em> process from your process list:</p>

<p><img src="http://schmichael.com/files/nginx-04-select-process.png" alt="Select Process" /></p>

<p>By default GDB will pause the process it attaches to, so make sure to click the Resume button (or press F8) to allow nginx to continue serving requests.</p>

<p><strong>Crashing nginx</strong></p>

<p>Now cause the segfault by running our curl command <code>curl -v -X PUT http://localhost:8888/foo</code>. This time curl won&rsquo;t return because gdb/Eclipse caught the segfault in the nginx child process, leaving the socket to curl open. A quick peek in Eclipse shows us exactly where the segfault occurs:</p>

<p><img src="http://schmichael.com/files/nginx-05-debugging.png" alt="Debugging in Eclipse" /></p>

<p>Eclipse makes it quick and easy to interactively inspect the variables. Doing that I discovered the culprit was the src variable being uninitialized. Bouncing up the stack once you can see dav&rsquo;s put handler expects to be given a temporary file (<code>&amp;#038;r-&gt;request_body-&gt;temp_file-&gt;file.name</code>) full of PUT data (of which we sent none), and it copies that to the destination file (<code>path</code>).</p>

<p>Bounce up the stack again to <code>ngx_http_read_client_request_body</code> and you can see this relevant code:</p>

<pre lang="c">if (r->headers_in.content_length_n &lt; 0) {</pre>

<p>nginx&rsquo;s core HTTP module short circuits a bit when there&rsquo;s no Content-Length specified. It skips the temp file creation because there&rsquo;s no data to put into the temp file!</p>

<p>So we have our problem:</p>

<ol>
<li>The dav module put handler expects a temp file containing the data to be saved.</li>
<li>The http module doesn&rsquo;t create a temp file when there&rsquo;s no body data.</li>
</ol>

<p>The 2 solutions I can think of are:</p>

<ol>
<li>Always create a temp file, even if it&rsquo;s empty.</li>
<li>Add a special case to the dav module&rsquo;s put handler for when the temp file doesn&rsquo;t exist.</li>
</ol>

<p>I really don&rsquo;t want to hack the core http module just to make a sub-module happy. It <em>makes sense</em> that no temporary file exists when there&rsquo;s no body data. Sub-modules shouldn&rsquo;t be lazy and expect it to exist. So I decided to try #2.</p>

<p><strong>The Fix</strong></p>

<p>You can see my <a href="https://github.com/schmichael/nginx/commit/c6051556460561bac4b0931fd9436e37b84925a3">implementation of solution #2 on GitHub</a>. Simply put, if the temp file exists, follow the existing logic. If the temp file does not exist we have a PUT with an empty body: use nginx&rsquo;s open wrapper to do a create or truncate (<code>O_CREAT|O_TRUNC</code>) on the destination file (since an empty PUT should create an empty file).</p>

<p>I don&rsquo;t know if this is the best solution or even a correct one, but it appears to work and was a fun journey arriving at it. You can [follow the discussion on the mailing list][20].</p>

<p><small>Updated to switch from bitbucket to github.</small></p>

<p>[20]: <a href="http://nginx.org/pipermail/nginx-devel/2010-December/000609.html">http://nginx.org/pipermail/nginx-devel/2010-December/000609.html</a></p>

   </div>
 </div>


 <a href="https://twitter.com/share" class="twitter-share-button " data-size="small" data-count="none">Tweet</a>
 <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

 <ul class="pager">
      &nbsp;<li class="previous"><a href="https://blog.schmichael.com/2011/01/25/deploying-python-behind-nginx-talk-slides/"> Deploying Python behind Nginx Talk Slides</a></li>
      &nbsp;<li class="next"><a href="https://blog.schmichael.com/2010/07/16/less-pagination-more-more/"> Less Pagination, More More</a></li>
</ul>



    </ul>
    </div>
    <footer>

        <p class="text-muted credit">&copy; . All rights reserved. </p>
    </footer>
 
    <script src="/js/jquery-1.10.2.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/bootstrap.js"></script>
    <script type="text/javascript" src="/js/hc.js"></script>
</body>

</html>

