<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on </title>
    <link>/categories/technology/</link>
    <description>Recent content in Technology on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 05 Nov 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Failing with MongoDB</title>
      <link>/2011/11/05/failing-with-mongodb/</link>
      <pubDate>Sat, 05 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/11/05/failing-with-mongodb/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Sorry this isn&amp;#8217;t my best piece of writing and there seems to be some confusion. The dataset in question was first in a 1.8 master/slave pair and then migrated to sharded replica sets and 2.0.0.&lt;/p&gt;

&lt;p&gt;For a bit of history of my dealings with MongoDB at Urban Airship, I gave a couple versions of a Scaling with MongoDB talk:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://opensourcebridge.org/2011/wiki/Scaling_with_MongoDB&#34;&gt;at Open Source Bridge (latest &amp;amp; greatest)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/2011/02/02/schmongodb-slides-from-update-portland/&#34;&gt;at Update Portland (original, less polished version)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My coworker Adam Lowry even gave a follow-up talk of sorts at &lt;a href=&#34;http://postgresopen.org/2011/schedule/presentations/98/&#34;&gt;Postgres Open 2011&lt;/a&gt; (&lt;a href=&#34;http://wiki.postgresql.org/images/7/7f/Adam-lowry-postgresopen2011.pdf&#34;&gt;slides&lt;/a&gt;) about migrating one of our datasets off of MongoDB and (back) on to PostgreSQL.&lt;/p&gt;

&lt;p&gt;After reading through those slides you&amp;#8217;re probably wondering why we&amp;#8217;re still dealing with MongoDB at all. We fully intended to migrate our data out of it by now, but priorities change, deadlines slip, and we never expected one of our last uses of MongoDB to experience a surge in growth.&lt;/p&gt;

&lt;p&gt;The dataset in question seemed ideal for MongoDB:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ephemeral &amp;#8211; if we lose it we experience service degradation for a short while, but nothing catastrophic&lt;/li&gt;
&lt;li&gt;Small &amp;#8211; easily fits into memory (~15 GB)&lt;/li&gt;
&lt;li&gt;Secondary index &amp;#8211; In a key/value store we would have had to manage a secondary index manually&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So this dataset dodged a lot of the previous problems we had with MongoDB and seemed safe to migrate at our leisure.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;global_write_lock&#34;&gt;&lt;b&gt;Global Write Lock&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mongodb.org/display/DOCS/How+does+concurrency+work#Howdoesconcurrencywork-Read%2FWriteLock&#34;&gt;MongoDB has a global write lock.&lt;/a&gt; This means that while applying an insert or update, a single mongod instance can&amp;#8217;t respond to other queries.&lt;/p&gt;

&lt;p&gt;Our dataset may be small but it has a heavy read and write load. When the service it backed experienced a surge in usage, MongoDB quickly became CPU bound. This was especially frustrating considering mongod was running in a simple master/slave setup on two servers: each with 16 cores and enough memory to hold all the data a few times over again.&lt;/p&gt;

&lt;p&gt;Because of the global write lock and heavy write load, operations are effectively serialized and executed on a single core. Meaning our servers didn&amp;#8217;t even look loaded, as just 1 core would be 100% utilized by mongod.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;sharding&#34;&gt;&lt;b&gt;Let the Sharding Begin&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So we need to utilize multiple cores&amp;#8230;&lt;/p&gt;

&lt;p&gt;To do that we need multiple write locks&amp;#8230;&lt;/p&gt;

&lt;p&gt;There&amp;#8217;s 1 write lock per mongod. So&amp;#8230;&lt;/p&gt;

&lt;p&gt;&amp;#8230;multiple mongods per server?&lt;/p&gt;

&lt;p&gt;We&amp;#8217;d been avoiding sharding after having no luck getting it working in the 1.5.x dev series, but it&amp;#8217;s our only choice now to get multiple mongods. I ran some tests and it seemed like we could turn our master/slave setup into a 2 shard setup with 2 mongods and 1 arbiter per shard with downtime in the seconds or low minutes.&lt;/p&gt;

&lt;p&gt;The operational complexity of configuring a MongoDB cluster is daunting with each component bringing its own caveats:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mongod config servers&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You need &lt;em&gt;exactly&lt;/em&gt; 3 config mongods (1 is fine for testing, which makes things appear simpler than they really are).&lt;/li&gt;
&lt;li&gt;There are lots of caveats with the config servers, so read &lt;a href=&#34;http://www.mongodb.org/display/DOCS/Changing+Config+Servers&#34;&gt;Changing Config Servers&lt;/a&gt; carefully before configuring your cluster.&lt;/li&gt;
&lt;li&gt;Otherwise these mongod instances are fairly blackboxish to me. Despite being mongod processes you administer them completely differently.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;mongos routers&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 per app server. This wouldn&amp;#8217;t be a big deal &lt;a href=&#34;http://www.mongodb.org/display/DOCS/flushRouterConfig+command&#34;&gt;except that our mongoses often start failing and require flushRouterConfig to be run on them&lt;/a&gt;. [2.0.1 supposedly fixes this][8], but we haven&amp;#8217;t tested that yet (and trading known problems for new unknown ones is always scary).&lt;/li&gt;
&lt;li&gt;mongos instances can use a lot of CPU and seem to have random spikes where they fully utilize every core very briefly. Keep this in mind if your application servers are already CPU bound.&lt;/li&gt;
&lt;li&gt;On the bright side mongos balanced our data rather quickly. Our shard key is a uuid, and it properly setup reasonable ranges in very short order without having to preconfigure them.&lt;/li&gt;
&lt;li&gt;&amp;#8220;mongos&amp;#8221; is a terribly confusing name. It sounds like multiple mongo instances. We&amp;#8217;ve taken to calling them mongooses internally due to frequent typos and confusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;arbiters&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You need at least 3 members in a replica set in order to complete an election if 1 member goes down.&lt;/li&gt;
&lt;li&gt;We haven&amp;#8217;t had any issues with arbiters&amp;#8230; not sure what we&amp;#8217;d do if one broke somehow but since they have no persistent data they&amp;#8217;re safe to restart at any time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;mongods&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Early on we ran into a problem where changing replica set member entries wasn&amp;#8217;t propagated to the config servers&amp;#8217; shard configuration. Restarting every mongos fixed it.&lt;/li&gt;
&lt;li&gt;As far as I can tell a new replica set member will never leave the initial RECOVERING state until all operations to that set are stopped. Even 40 updates per second was enough of a trickle to prevent a new set member from leaving RECOVERING to becoming a SECONDARY. We had to shutdown mongoses to cut off all traffic to bring up a new member. (The replication log gave every indication of being caught up and our usual update load is thousands per second.)&lt;/li&gt;
&lt;li&gt;Setting rest in the config file doesn&amp;#8217;t seem to work. Put &amp;#8211;rest in your command line options.&lt;/li&gt;
&lt;li&gt;Sending an HTTP request to a mongod&amp;#8217;s main port (instead of the HTTP endpoint) seems to be capable of crashing the mongod.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Client Drivers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While a single replica set member was in a RECOVERING state our Java services couldn&amp;#8217;t complete &lt;em&gt;any&lt;/em&gt; operations while our Python service was happily working away.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Right now we&amp;#8217;re getting by with 2 shards on 2 dedicated servers and then mongoses and config servers spread throughout other servers. There appears to be some data loss occurring, though due to the ephemeral fast changing nature of this dataset it&amp;#8217;s very difficult to determine definitively or reproduce independently.&lt;/p&gt;

&lt;p&gt;So we&amp;#8217;re trying to migrate off of MongoDB to a custom service better suited for this dataset ASAP.&lt;/p&gt;

&lt;p&gt;[8]: &lt;a href=&#34;https://jira.mongodb.org/browse/SERVER-3739&#34;&gt;https://jira.mongodb.org/browse/SERVER-3739&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MemoryMapFile Convenience Class for Python</title>
      <link>/2011/09/05/memorymapfile-convenience-class-for-python/</link>
      <pubDate>Tue, 06 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/05/memorymapfile-convenience-class-for-python/</guid>
      <description>&lt;p&gt;My &lt;a href=&#34;/2011/05/15/sharing-python-data-between-processes-using-mmap/&#34;&gt;obsession&lt;/a&gt; with &lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap&lt;/a&gt; hasn&amp;#8217;t died, but while &lt;a href=&#34;http://docs.python.org/library/mmap&#34;&gt;Python&amp;#8217;s mmap module&lt;/a&gt; is a wonderful low level library it&amp;#8217;s a bit hard for a newcomer to use properly.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve started toying with a convenience wrapper class for &lt;code&gt;mmap.mmap&lt;/code&gt; (at least the Unix version):&lt;/p&gt;

&lt;p&gt;My original goal was to automatically &lt;a href=&#34;http://docs.python.org/library/mmap#mmap.resize&#34;&gt;grow&lt;/a&gt; the mmap whenever the user attempts to write beyond the current size of the mmap file, but that&amp;#8217;s going to take carefully wrapping quite a few methods (&lt;code&gt;write&lt;/code&gt;, &lt;code&gt;__setitem__&lt;/code&gt;, and maybe get/read methods too).&lt;/p&gt;

&lt;p&gt;If it becomes useful, I may use it in [mmstats][5].&lt;/p&gt;

&lt;p&gt;Feedback welcome!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Discovered the hard way (segfaults) that resizing mmaps is tricky: the region can be moved but data will be copied. However, any existing pointers (from ctypes.&lt;type&gt;.from_buffer in my case) will now point to freed memory and segfault upon use.&lt;/p&gt;

&lt;p&gt;tl;dr &amp;#8211; If at all possible, precompute the size of your mmap before using it.&lt;/p&gt;

&lt;p&gt;[5]: &lt;a href=&#34;https://github.com/schmichael/mmstats&#34;&gt;https://github.com/schmichael/mmstats&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sharing Python data between processes using mmap</title>
      <link>/2011/05/15/sharing-python-data-between-processes-using-mmap/</link>
      <pubDate>Mon, 16 May 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/05/15/sharing-python-data-between-processes-using-mmap/</guid>
      <description>&lt;p&gt;I&amp;#8217;ve been toying with an idea of exposing statistics for a Python application via shared memory to keep the performance impact on the application as low as possible. The goal being an application could passively expose a number of metrics that could either be periodically polled via &lt;a href=&#34;http://munin-monitoring.org/&#34;&gt;munin&lt;/a&gt;/&lt;a href=&#34;http://www.icinga.org/&#34;&gt;Icinga&lt;/a&gt;/etc plugins or interactive tools when diagnosing issues on a system.&lt;/p&gt;

&lt;p&gt;But first things first: I need to put data into &lt;a href=&#34;http://en.wikipedia.org/wiki/Shared_memory&#34;&gt;shared memory&lt;/a&gt; from Python. &lt;a href=&#34;http://en.wikipedia.org/wiki/Mmap&#34;&gt;mmap&lt;/a&gt; is an excellent widely-implemented POSIX system call for creating a shared memory space backed by an on-disk file.&lt;/p&gt;

&lt;p&gt;Usually in the UNIX world you have 2 ways of accessing/manipulating data: memory addresses or streams (files). Manipulating data via memory addresses means &lt;a href=&#34;http://en.wikipedia.org/wiki/Pointer_%28computing%29&#34;&gt;pointers&lt;/a&gt;, offsets, &lt;a href=&#34;http://en.wikipedia.org/wiki/Malloc&#34;&gt;malloc/free&lt;/a&gt;, etc. Stream interfaces manipulate data via &lt;a href=&#34;http://en.wikipedia.org/wiki/System_call&#34;&gt;read/write/seek system calls&lt;/a&gt; for files and &lt;a href=&#34;http://en.wikipedia.org/wiki/Berkeley_sockets&#34;&gt;send/recv/etc for sockets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;mmap gives you both interfaces. A memory mapped file can be manipulated via read/write/seek or by directly accessing its mapped memory region. The advantage of the latter is that this memory region is in userspace &amp;#8212; meaning you can manipulate a file without incurring the overhead of write system calls for every manipulation.&lt;/p&gt;

&lt;p&gt;Anyway, enough exposition, let&amp;#8217;s see some code. &lt;small&gt;(Despite mmap&amp;#8217;s nice featureset, I&amp;#8217;m only using it as a simple memory sharing mechanism anyway.)&lt;/small&gt; The following code shares a tiny bit of data between 2 Python processes using the excellent &lt;a href=&#34;http://docs.python.org/library/mmap&#34;&gt;mmap module in the stdlib&lt;/a&gt;. &lt;code&gt;a.py&lt;/code&gt; writes to the memory mapped region, and &lt;code&gt;b.py&lt;/code&gt; reads the data out. [ctypes][10] allows for an easy way to create values in a memory mapped region and manipulate them like &amp;#8220;normal&amp;#8221; Python objects.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;These code samples were written using Python 2.7 on Linux. They should work fine on any POSIX system, but Windows users will have to change the mmap calls to match the Windows API.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a.py&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;#!/usr/bin/env python
import ctypes
import mmap
import os
import struct


def main():
    # Create new empty file to back memory map on disk
    fd = os.open(&#39;/tmp/mmaptest&#39;, os.O_CREAT | os.O_TRUNC | os.O_RDWR)

    # Zero out the file to insure it&#39;s the right size
    assert os.write(fd, &#39;\x00&#39; * mmap.PAGESIZE) == mmap.PAGESIZE

    # Create the mmap instace with the following params:
    # fd: File descriptor which backs the mapping or -1 for anonymous mapping
    # length: Must in multiples of PAGESIZE (usually 4 KB)
    # flags: MAP_SHARED means other processes can share this mmap
    # prot: PROT_WRITE means this process can write to this mmap
    buf = mmap.mmap(fd, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_WRITE)

    # Now create an int in the memory mapping
    i = ctypes.c_int.from_buffer(buf)

    # Set a value
    i.value = 10

    # And manipulate it for kicks
    i.value += 1
    
    assert i.value == 11

    # Before we create a new value, we need to find the offset of the next free
    # memory address within the mmap
    offset = struct.calcsize(i._type_)

    # The offset should be uninitialized (&#39;\x00&#39;)
    assert buf[offset] == &#39;\x00&#39;

    # Now ceate a string containing &#39;foo&#39; by first creating a c_char array
    s_type = ctypes.c_char * len(&#39;foo&#39;)

    # Now create the ctypes instance
    s = s_type.from_buffer(buf, offset)

    # And finally set it
    s.raw = &#39;foo&#39;

    print &#39;First 10 bytes of memory mapping: %r&#39; % buf[:10]
    raw_input(&#39;Now run b.py and press ENTER&#39;)

    print
    print &#39;Changing i&#39;
    i.value *= i.value

    print &#39;Changing s&#39;
    s.raw = &#39;bar&#39;

    new_i = raw_input(&#39;Enter a new value for i: &#39;)
    i.value = int(new_i)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;b.py&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;import mmap
import os
import struct
import time

def main():
    # Open the file for reading
    fd = os.open(&#39;/tmp/mmaptest&#39;, os.O_RDONLY)

    # Memory map the file
    buf = mmap.mmap(fd, mmap.PAGESIZE, mmap.MAP_SHARED, mmap.PROT_READ)

    i = None
    s = None

    while 1:
        new_i, = struct.unpack(&#39;i&#39;, buf[:4])
        new_s, = struct.unpack(&#39;3s&#39;, buf[4:7])

        if i != new_i or s != new_s:
            print &#39;i: %s =&gt; %d&#39; % (i, new_i)
            print &#39;s: %s =&gt; %s&#39; % (s, new_s)
            print &#39;Press Ctrl-C to exit&#39;
            i = new_i
            s = new_s

        time.sleep(1)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;(Note that I cruelly don&amp;#8217;t clean up /tmp/mmaptest after the scripts finished. Consider it a 4KB tax for anyone who runs arbitrary code they found on the Internet without reading it first.)&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;[10]: &lt;a href=&#34;http://docs.python.org/library/ctypes&#34;&gt;http://docs.python.org/library/ctypes&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>signalfd</title>
      <link>/2011/02/20/signalfd/</link>
      <pubDate>Mon, 21 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/02/20/signalfd/</guid>
      <description>&lt;p&gt;&lt;em&gt;This article covers&lt;/em&gt; signalfd&lt;em&gt;, a system call only available on Linux. If anyone knows of an equivalent for OSX or BSDs,&lt;abbrev title=&#34;If there&#39;s something like signalfd for Windows, I&#39;m sorry but I really couldn&#39;t care less.&#34;&gt;*&lt;/abbrev&gt; please &lt;a href=&#34;/about-me/&#34;&gt;let me know&lt;/a&gt;. It&amp;#8217;d be great to create a compatibility layer.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Writing asynchronous IO code is fun; handling signals is not. &lt;a href=&#34;http://www.kernel.org/doc/man-pages/online/pages/man2/signalfd.2.html&#34;&gt;signalfd&lt;/a&gt; allows you to move your signal handling code into your main event loop instead of hooking up global handlers and using the featureless &lt;a href=&#34;http://docs.python.org/library/signal#signal.set_wakeup_fd&#34;&gt;set_wakeup_fd&lt;/a&gt; function to break the main loop.&lt;/p&gt;

&lt;p&gt;Luckily &lt;a href=&#34;https://launchpad.net/python-signalfd&#34;&gt;Jean-Paul Calderone had already created a great Python wrapper for the signalfd and sigprocmask system calls&lt;/a&gt;. Unfortunately it doesn&amp;#8217;t include a way to parse the siginfo_t structure which contains all the useful information about the signal you&amp;#8217;re handling.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve added a helper to do just that in a branch:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.launchpad.net/~schmichael/python-signalfd/helpers&#34;&gt;https://code.launchpad.net/~schmichael/python-signalfd/helpers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A sample program would look like:&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;import os
import select
import signal

import signalfd


def sigfdtest():
    # Catch them all!
    sigs = []
    for attr in dir(signal):
        if attr.startswith(&#39;SIG&#39;) and not attr.startswith(&#39;SIG_&#39;):
            sigs.append(getattr(signal, attr))

    sfd = signalfd.create_signalfd(sigs)
    print &#39;Capturing: %r&#39; % sorted(sigs)
    
    while 1:
        print &#39;selecting - pid: %d&#39; % os.getpid()
        r = select.select([sfd], [], [])[0]
        for s in r:
            assert s is sfd, &#39;Python nicely re-uses the fd instance&#39;
            sig = signalfd.read_signalfd(sfd)
            print sig
                

if __name__ == &#39;__main__&#39;:
    sigfdtest()
&lt;/pre&gt;

&lt;p&gt;When run you can throw some signals at it:&lt;/p&gt;

&lt;pre&gt;Capturing: [6, 14, 7, 17, 17, 18, 8, 1, 4, 2, 29, 6, 9, 13, 29, 27, 30, 3, 64, 34, 11, 19, 31, 15, 5, 20, 21, 22, 23, 10, 12, 26, 28, 24, 25]
selecting - pid: 6523
^CSIGINT
selecting - pid: 6523
^CSIGINT
selecting - pid: 6523
SIGHUP
selecting - pid: 6523
Killed
&lt;/pre&gt;

&lt;p&gt;Of course you&amp;#8217;ll need to use an uninterpretable signal like KILL to exit.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bugs.python.org/issue8407&#34;&gt;Jean-Paul attempted to get signalfd included in Python 2.7&amp;#8217;s signal module, and it was slated for inclusion in 3.2&lt;/a&gt;. However, given that &lt;a href=&#34;http://www.python.org/download/releases/3.2/&#34;&gt;3.2&lt;/a&gt; was just &lt;a href=&#34;http://docs.python.org/release/3.2/library/signal&#34;&gt;released without it&lt;/a&gt;, I&amp;#8217;m guessing the attempt to get this functionality into Python&amp;#8217;s stdlib has been forgotten.&lt;/p&gt;

&lt;p&gt;Up next: [eventfd][8] perhaps?&lt;/p&gt;

&lt;p&gt;[8]: &lt;a href=&#34;http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd.2.html&#34;&gt;http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd.2.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>schmongodb slides from Update Portland</title>
      <link>/2011/02/02/schmongodb-slides-from-update-portland/</link>
      <pubDate>Thu, 03 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/02/02/schmongodb-slides-from-update-portland/</guid>
      <description>&lt;p&gt;A few months ago someone in #pdxwebdev on Freenode asked an innocent &lt;a href=&#34;http://www.mongodb.org&#34;&gt;MongoDB&lt;/a&gt; question. In response I ranted seemingly endlessly about our experience with MongoDB at &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt;. After a few moments somebody (perhaps sarcastically? who can know on IRC) suggested I give a talk on my experiences with MongoDB. That led me to realize despite &lt;a href=&#34;http://calagator.org/&#34;&gt;Portland&amp;#8217;s amazing meetup culture&lt;/a&gt; there were no tech-meetups that focused on either:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Narrative talks based on experiences in production &lt;small&gt;(&lt;em&gt;not&lt;/em&gt; how-tos)&lt;/small&gt;&lt;/li&gt;
&lt;li&gt;Database-agnostic backend systems focused groups &lt;small&gt;(&lt;em&gt;not&lt;/em&gt; just a NoSQL meetup)&lt;/small&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So I started one: &lt;a href=&#34;http://www.meetup.com/updatepdx/&#34;&gt;Update Portland&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And I gave my promised MongoDB talk: &lt;a href=&#34;https://docs.google.com/present/view?id=ddzswzbr_104f2sgp8dq&#34;&gt;schmongodb&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And &lt;a href=&#34;http://twitter.com/meghanpgill/status/23455639216848896&#34;&gt;10gen sent swag&lt;/a&gt;! (Thanks to &lt;a href=&#34;http://twitter.com/meghanpgill&#34;&gt;Meghan&lt;/a&gt;! It was a big hit.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And&lt;/em&gt; my brilliant coworker &lt;a href=&#34;http://twitter.com/eonnen&#34;&gt;Erik Onnen&lt;/a&gt; gave a short talk on how he&amp;#8217;s beginning to use &lt;a href=&#34;http://sna-projects.com/kafka/&#34;&gt;Kafka&lt;/a&gt; at Urban Airship. (Expect a long form talk on that in the future!)&lt;/p&gt;

&lt;p&gt;Thanks to everyone who showed up. I had a great time and have high hopes for the upcoming meetings. (Sign up for the &lt;a href=&#34;http://groups.google.com/group/update-pdx&#34;&gt;mailing list&lt;/a&gt;!)&lt;/p&gt;

&lt;p&gt;The slides may come across as overly negative. After all Urban Airship is actively moving away from MongoDB for our largest and busiest pieces of data. So I want to make 2 things very clear:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I like MongoDB and would like to use it again in the future. There&amp;#8217;s a lot I don&amp;#8217;t like about it, but I can&amp;#8217;t think of any &amp;#8220;perfect&amp;#8221; piece of software.&lt;/li&gt;
&lt;li&gt;The IO situation in EC2, particularly EBS&amp;#8217;s poor performance (RAIDing really doesn&amp;#8217;t help) made life with MongoDB miserable. This story may have been very different if we were running MongoDB on bare metal with fast disks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[Mike Herrick, the VP of Engineering at Urban Airship][11], put me on the spot at the end of my talk by asking me by asking me: &lt;strong&gt;&amp;#8220;Knowing what you know now, what would you have done differently?&amp;#8221;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I didn&amp;#8217;t have a good answer, and I still don&amp;#8217;t. Despite all of the misadventures, MongoDB wasn&amp;#8217;t the wrong choice. Scaling systems is just hard, and if you want something to work under load, you&amp;#8217;re going to have to learn all of its ins and outs. We initially started moving to Cassandra, and while it has tons of wonderful attributes, we&amp;#8217;re running into plenty of problems with it as well.&lt;/p&gt;

&lt;p&gt;So I think the answer is &lt;em&gt;knowing then what I know now&lt;/em&gt;. In other words: &lt;strong&gt;Do your homework&lt;/strong&gt;. That way we could have avoided these shortcomings and perhaps still be happy with MongoDB today. Hopefully these slides will help others in how they plan to use MongoDB so they can use it properly and happily.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I added lots of comments to the speaker notes, so you&amp;#8217;ll probably want to view those while looking at the slides.&lt;/p&gt;

&lt;p&gt;[11]: &lt;a href=&#34;http://www.mikeherrick.com/&#34;&gt;http://www.mikeherrick.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploying Python behind Nginx Talk Slides</title>
      <link>/2011/01/25/deploying-python-behind-nginx-talk-slides/</link>
      <pubDate>Tue, 25 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/01/25/deploying-python-behind-nginx-talk-slides/</guid>
      <description>&lt;p&gt;I gave a talk on deploying Python WSGI apps behind &lt;a href=&#34;http://wiki.nginx.org/&#34;&gt;nginx&lt;/a&gt; at the &lt;a href=&#34;http://wiki.python.org/moin/PortlandPythonUserGroup&#34;&gt;Portland Python User Group&lt;/a&gt; meeting on January 11th and finally got around to publishing the slides: &lt;a href=&#34;https://docs.google.com/present/edit?id=0Ab7GDIugV1qCZGR6c3d6YnJfMTA1aGRtZmJxYzI&amp;amp;hl=en&#34;&gt;schmingx&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I should mention &lt;a href=&#34;http://discorporate.us/jek/&#34;&gt;Jason Kirtland&lt;/a&gt; informed me after the meeting that &lt;a href=&#34;http://www.fastcgi.com/devkit/doc/fcgi-spec.html&#34;&gt;FastCGI&lt;/a&gt; supports [persistent connections (and a host of other features)][6] between a load balancer and backend app servers.&lt;/p&gt;

&lt;p&gt;[6]: &lt;a href=&#34;http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S3.5&#34;&gt;http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S3.5&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Complete Noobs Guide to Hacking Nginx</title>
      <link>/2010/12/28/noobs-guide-to-hacking-nginx/</link>
      <pubDate>Wed, 29 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/12/28/noobs-guide-to-hacking-nginx/</guid>
      <description>&lt;p&gt;At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``&lt;/p&gt;

&lt;p&gt;Success! Now create a patch &lt;code&gt;diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch&lt;/code&gt; and &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000605.html&#34;&gt;post it to the nginx-devel mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Second Pass: Fixing WebDAV&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A positive &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000606.html&#34;&gt;reply from Maxim Dounin to my patch&lt;/a&gt;! I don&amp;rsquo;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&amp;rsquo;t break official modules.&lt;/p&gt;

&lt;p&gt;This time around I wanted to work locally, so I installed nginx with the following configuration:&lt;/p&gt;

&lt;p&gt;```At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``At &lt;a href=&#34;http://urbanairship.com&#34;&gt;Urban Airship&lt;/a&gt; our &lt;a href=&#34;http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services&#34;&gt;RESTful HTTP API&lt;/a&gt; uses PUT requests for, among other things, &lt;a href=&#34;http://urbanairship.com/docs/push.html#registration&#34;&gt;registering a device&lt;/a&gt;. Since the application registering the device is the HTTP Basic Auth username, there&amp;#8217;s often no body (&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2&#34;&gt;entity body&lt;/a&gt; in HTTP parlance). Unfortunately &lt;a href=&#34;http://wiki.nginx.org&#34;&gt;nginx&lt;/a&gt; (as of 0.8.54, and I believe 0.9.3) doesn&amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the &lt;a href=&#34;http://wiki.nginx.org/HttpChunkinModule&#34;&gt;chunkin&lt;/a&gt; module adds Transfer-Encoding: chunked support, it doesn&amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;#8217;t require Content-Length nor Transfer-Encoding headers.&lt;/p&gt;

&lt;p&gt;So let&amp;#8217;s hack nginx shall we?&lt;/p&gt;

&lt;p&gt;I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;#8217;s no official public source repository (&lt;a href=&#34;https://github.com/git-mirror/nginx&#34;&gt;but there&amp;#8217;s a mirror&lt;/a&gt;) and it seems to be mainly developed by the creator, &lt;a href=&#34;http://sysoev.ru/en/&#34;&gt;Igor Sysoev&lt;/a&gt;. At least the code looks clean.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I had &lt;a href=&#34;http://nginx.org/download/nginx-0.8.54.tar.gz&#34;&gt;nginx-0.8.54.tar.gz&lt;/a&gt; handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;client sent PUT method without &amp;#8220;Content-Length&amp;#8221; header while reading client request headers, client: &amp;#8230;, server: , request: &amp;#8220;PUT / HTTP/1.1&amp;#8221; &amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let&amp;#8217;s use &lt;a href=&#34;http://betterthangrep.com/&#34;&gt;ack&lt;/a&gt; to find it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-01-ack.png&#34; alt=&#34;ack-grep &#39;client sent .* method without&#39;&#34; title=&#34;ack-grep &#39;client sent .* method without&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A quick &lt;code&gt;vim +1532 src/http/ngx_http_request.c&lt;/code&gt; later and we&amp;#8217;re looking at the problem:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;method &amp;#038; NGX_HTTP_PUT &amp;#038;&amp;#038; r-&gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0,
                  &#34;client sent %V method without \&#34;Content-Length\&#34; header&#34;,
                  &amp;#038;r-&gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&lt;/pre&gt;

&lt;p&gt;This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (&lt;code&gt;make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart&lt;/code&gt;), and test:&lt;/p&gt;

&lt;p&gt;``&lt;/p&gt;

&lt;p&gt;Success! Now create a patch &lt;code&gt;diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch&lt;/code&gt; and &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000605.html&#34;&gt;post it to the nginx-devel mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Second Pass: Fixing WebDAV&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A positive &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000606.html&#34;&gt;reply from Maxim Dounin to my patch&lt;/a&gt;! I don&amp;rsquo;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&amp;rsquo;t break official modules.&lt;/p&gt;

&lt;p&gt;This time around I wanted to work locally, so I installed nginx with the following configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.&lt;/p&gt;

&lt;p&gt;The importance of being able to attach a debugger became clear as soon as I tested &lt;a href=&#34;http://wiki.nginx.org/HttpDavModule&#34;&gt;dav support (with their standard config)&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
My patch was causing a segfault in the dav module that killed nginx&#39;s worker process. Bumping up my error logging to `debug` level didn&#39;t give me many clues:
  
`````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

``` 

Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
````At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

```At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

``At [Urban Airship][1] our [RESTful HTTP API][2] uses PUT requests for, among other things, [registering a device][3]. Since the application registering the device is the HTTP Basic Auth username, there&amp;amp;#8217;s often no body ([entity body][4] in HTTP parlance). Unfortunately [nginx][5] (as of 0.8.54, and I believe 0.9.3) doesn&amp;amp;#8217;t support PUT requests without a Content-Length header and responds with a 411 Length Required response. While the [chunkin][6] module adds Transfer-Encoding: chunked support, it doesn&amp;amp;#8217;t fix the empty PUT problem since HTTP requests without bodies don&amp;amp;#8217;t require Content-Length nor Transfer-Encoding headers.

So let&amp;amp;#8217;s hack nginx shall we?

I know a bit of C but am primarily a Python developer, so hacking an established C project doesn&amp;amp;#8217;t come easily to me. To make matters worse, as far as I can tell there&amp;amp;#8217;s no official public source repository ([but there&amp;amp;#8217;s a mirror][7]) and it seems to be mainly developed by the creator, [Igor Sysoev][8]. At least the code looks clean.

**First Pass**

I had [nginx-0.8.54.tar.gz][9] handy from compiling the source and nginx was nice enough to log an error for PUTs without Content-Length:

&amp;gt; client sent PUT method without &amp;amp;#8220;Content-Length&amp;amp;#8221; header while reading client request headers, client: &amp;amp;#8230;, server: , request: &amp;amp;#8220;PUT / HTTP/1.1&amp;amp;#8221; &amp;amp;#8230; 

So let&amp;amp;#8217;s use [ack][10] to find it:

![ack-grep &#39;client sent .* method without&#39;][11]

A quick `vim +1532 src/http/ngx_http_request.c` later and we&amp;amp;#8217;re looking at the problem:

&amp;lt;pre lang=&amp;quot;c&amp;quot;&amp;gt;if (r-&amp;gt;method &amp;amp;#038; NGX_HTTP_PUT &amp;amp;#038;&amp;amp;#038; r-&amp;gt;headers_in.content_length_n == -1) {
        ngx_log_error(NGX_LOG_INFO, r-&amp;gt;connection-&amp;gt;log, 0,
                  &amp;quot;client sent %V method without \&amp;quot;Content-Length\&amp;quot; header&amp;quot;,
                  &amp;amp;#038;r-&amp;gt;method_name);
        ngx_http_finalize_request(r, NGX_HTTP_LENGTH_REQUIRED);
        return NGX_ERROR;
    }&amp;lt;/pre&amp;gt;

This code returns the 411 Length Required response for PUTs lacking a Content-Length header. Remove it, recompile (`make -j2 &amp;amp;#038;&amp;amp;#038; sudo make install &amp;amp;#038;&amp;amp;#038; sudo service nginx restart`), and test:

`` 

Success! Now create a patch `diff -ru nginx-0.8.54 nginx &amp;gt; fix-empty-put.patch` and [post it to the nginx-devel mailing list][12].

Now to play Minecraft for 12 hours as you wait for the Russian developers to wake up and take notice of your patch. Possibly sleep.

**Second Pass: Fixing WebDAV**

A positive [reply from Maxim Dounin to my patch][13]! I don&#39;t use WebDAV though, but if I want this patch accepted I better make sure it doesn&#39;t break official modules.

This time around I wanted to work locally, so I installed nginx with the following configuration:

``` 

Note that I set the prefix to a path in my home directory, turned on debugging and the dav module, and set nginx to run as my user and group. A quick symlink from /home/schmichael/local/nginx/sbin/nginx to ~/bin/nginx, and I can start and restart nginx quickly and easily. More importantly I can attach a debugger to it.

The importance of being able to attach a debugger became clear as soon as I tested [dav support (with their standard config)][14]:
  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My patch was causing a segfault in the dav module that killed nginx&amp;rsquo;s worker process. Bumping up my error logging to &lt;code&gt;debug&lt;/code&gt; level didn&amp;rsquo;t give me many clues:&lt;/p&gt;

&lt;p&gt;`````&lt;/p&gt;

&lt;p&gt;Time to break out the debugger! While I&amp;rsquo;ve used &lt;code&gt;gdb --pid&lt;/code&gt; to attach to running processes before, I&amp;rsquo;d just installed Eclipse to work on some Java code and wondered if it might make debugging a bit easier.&lt;/p&gt;

&lt;p&gt;After installing plugins for C/C++, Autotools, and GDB, I could easily import nginx by creating a &amp;ldquo;New Makefile project with existing code&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-02-import-existing.png&#34; alt=&#34;Import existing code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now create a new Debug Configuration:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-03-debug-conf.png&#34; alt=&#34;Debug Configuration&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt; on Linux systems (at least Ubuntu):&lt;/em&gt; by default PTRACE is disabled in the kernel. Just flip the 1 to 0 in &lt;code&gt;/etc/sysctl.d/10-ptrace.conf&lt;/code&gt; and run &lt;code&gt;sudo sysctl -p /etc/sysctl.d/10-ptrace.conf&lt;/code&gt; to allow PTRACE.&lt;/p&gt;

&lt;p&gt;Finally click &amp;ldquo;Debug&amp;rdquo; and select the nginx &lt;em&gt;worker&lt;/em&gt; process from your process list:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-04-select-process.png&#34; alt=&#34;Select Process&#34; /&gt;&lt;/p&gt;

&lt;p&gt;By default GDB will pause the process it attaches to, so make sure to click the Resume button (or press F8) to allow nginx to continue serving requests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crashing nginx&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now cause the segfault by running our curl command &lt;code&gt;curl -v -X PUT http://localhost:8888/foo&lt;/code&gt;. This time curl won&amp;rsquo;t return because gdb/Eclipse caught the segfault in the nginx child process, leaving the socket to curl open. A quick peek in Eclipse shows us exactly where the segfault occurs:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/nginx-05-debugging.png&#34; alt=&#34;Debugging in Eclipse&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Eclipse makes it quick and easy to interactively inspect the variables. Doing that I discovered the culprit was the src variable being uninitialized. Bouncing up the stack once you can see dav&amp;rsquo;s put handler expects to be given a temporary file (&lt;code&gt;&amp;amp;#038;r-&amp;gt;request_body-&amp;gt;temp_file-&amp;gt;file.name&lt;/code&gt;) full of PUT data (of which we sent none), and it copies that to the destination file (&lt;code&gt;path&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Bounce up the stack again to &lt;code&gt;ngx_http_read_client_request_body&lt;/code&gt; and you can see this relevant code:&lt;/p&gt;

&lt;pre lang=&#34;c&#34;&gt;if (r-&gt;headers_in.content_length_n &amp;lt; 0) {&lt;/pre&gt;

&lt;p&gt;nginx&amp;rsquo;s core HTTP module short circuits a bit when there&amp;rsquo;s no Content-Length specified. It skips the temp file creation because there&amp;rsquo;s no data to put into the temp file!&lt;/p&gt;

&lt;p&gt;So we have our problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The dav module put handler expects a temp file containing the data to be saved.&lt;/li&gt;
&lt;li&gt;The http module doesn&amp;rsquo;t create a temp file when there&amp;rsquo;s no body data.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The 2 solutions I can think of are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Always create a temp file, even if it&amp;rsquo;s empty.&lt;/li&gt;
&lt;li&gt;Add a special case to the dav module&amp;rsquo;s put handler for when the temp file doesn&amp;rsquo;t exist.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I really don&amp;rsquo;t want to hack the core http module just to make a sub-module happy. It &lt;em&gt;makes sense&lt;/em&gt; that no temporary file exists when there&amp;rsquo;s no body data. Sub-modules shouldn&amp;rsquo;t be lazy and expect it to exist. So I decided to try #2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Fix&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can see my &lt;a href=&#34;https://github.com/schmichael/nginx/commit/c6051556460561bac4b0931fd9436e37b84925a3&#34;&gt;implementation of solution #2 on GitHub&lt;/a&gt;. Simply put, if the temp file exists, follow the existing logic. If the temp file does not exist we have a PUT with an empty body: use nginx&amp;rsquo;s open wrapper to do a create or truncate (&lt;code&gt;O_CREAT|O_TRUNC&lt;/code&gt;) on the destination file (since an empty PUT should create an empty file).&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know if this is the best solution or even a correct one, but it appears to work and was a fun journey arriving at it. You can [follow the discussion on the mailing list][20].&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Updated to switch from bitbucket to github.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;[20]: &lt;a href=&#34;http://nginx.org/pipermail/nginx-devel/2010-December/000609.html&#34;&gt;http://nginx.org/pipermail/nginx-devel/2010-December/000609.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Less Pagination, More More</title>
      <link>/2010/07/16/less-pagination-more-more/</link>
      <pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/07/16/less-pagination-more-more/</guid>
      <description>&lt;p&gt;We live in a brave new (to some) world of databases other than a relational database with a SQL interface. Normally end users never notice a difference, but the astute viewer may notice the slow demise of an old friend: pagination.&lt;/p&gt;

&lt;p&gt;Traditionally with SQL databases pagination has looked something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/pagination.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There are previous and next links as well as links for jumping right to the beginning and end. Pretty boring stuff.&lt;/p&gt;

&lt;p&gt;What&amp;#8217;s interesting is that this standard interface is disappearing in favor of something like this:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Twitter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/twitter-more.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Facebook&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/facebook-more.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And soon beta testers of &lt;a href=&#34;http://blog.urbanairship.com/2010/05/25/android-delivers-push-notifications-are-here-to-stay/&#34;&gt;Urban Airship&amp;#8217;s push service for Android&lt;/a&gt; will see a More link on the page that lists devices associated with their app:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://schmichael.com/files/apids-more.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The simplest possible explanation for this dumbing down of pagination is that &lt;strong&gt;count (for total pages) and skip/offset are expensive operations.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Not only are those operations expensive, but in eventually consistent databases, which many modern non-relational databases are, they&amp;#8217;re extremely expensive, if not impossible, to perform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cassandra&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At Urban Airship we, like Facebook, use &lt;a href=&#34;http://cassandra.apache.org/&#34;&gt;Cassandra&lt;/a&gt;: a distributed column-based database. This deals two deadly blows to traditional pagination:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;No way to count columns in a row (without reading every column).&lt;/li&gt;
&lt;li&gt;No way to skip by numeric offset (so you can&amp;#8217;t say, skip to page 5).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Cassandra columns are ordered, so you start reading from the beginning and read N+1 columns where N is the number of items you&amp;#8217;d like to display. The last column&amp;#8217;s key is then used to determine whether the More link is enabled, and if so, what key to start the next &amp;#8220;page&amp;#8221; at.&lt;/p&gt;

&lt;p&gt;Both of those are solvable problems if you really need them, but I would suspect you would end up creating a column count cache as well as some sort of table of contents for the various page offsets. Not what I want to spend my time implementing.&lt;/p&gt;

&lt;p&gt;The fact of the matter is that for many use cases, a simple More button works just as well (if not better) than traditional pagination. It&amp;#8217;s also far cheaper to implement, which means more developer time free to work on features and more hardware resources available to push your 140 character insights around the web.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I should note that MongoDB is fairly unique in the non-relational database world as its dynamic querying features include &lt;a href=&#34;http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count&#34;&gt;count&lt;/a&gt; and [skip][8] operations. However, as with any database, you&amp;#8217;ll want to make sure these queries hit indexes.&lt;/p&gt;

&lt;p&gt;Sadly MongoDB currently doesn&amp;#8217;t have the distributed features necessary to automatically handle data too big for a single server.&lt;/p&gt;

&lt;p&gt;[8]: &lt;a href=&#34;http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D&#34;&gt;http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making Server-Side MongoDB Functions Less Awkward</title>
      <link>/2010/01/11/making-server-side-mongodb-functions-less-awkward/</link>
      <pubDate>Tue, 12 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/01/11/making-server-side-mongodb-functions-less-awkward/</guid>
      <description>&lt;p&gt;I&amp;#8217;ve recently switched my project at work to use MongoDB for the user database and a few other datasets.&lt;/p&gt;

&lt;p&gt;Currently I don&amp;#8217;t use many JavaScript functions, but when I do I like to store them on the server so that they&amp;#8217;re accessible when I&amp;#8217;m poking around in a console.&lt;/p&gt;

&lt;p&gt;I use something similar to the following function to load all of my JS functions onto the server when my app starts:&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;import os
import pymongo
import pkg_resources

# Relative to distribution&#39;s root
SCRIPT_DIR = os.path.join(&#39;model&#39;, &#39;js&#39;)

def init_js(db):
    &#39;&#39;&#39;Initializes server-side javascript functions&#39;&#39;&#39;
    scripts = filter(
            lambda f: f.endswith(&#39;.js&#39;),
            pkg_resources.resource_listdir(__name__, SCRIPT_DIR)
        )
    for script in scripts:
        # Name the function after the script name
        func_name, _ = script.split(&#39;.&#39;, 1)
        script_path = os.path.join(SCRIPT_DIR, script)

        # Create a pymongo Code object
        # otherwise it will be stored as a string
        code = pymongo.code.Code(
                pkg_resources.resource_string(__name__, script_path))

        # Upsert the function
        db.system.js.save({ &#39;_id&#39;: func_name, &#39;value&#39;: code, })
&lt;/pre&gt;

&lt;p&gt;However, using server-side functions from Python is awkward at best. Say I have the JavaScript function:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;add.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&#34;javascript&#34;&gt;function(x, y) {
    return x + y;
}
&lt;/pre&gt;

&lt;p&gt;To run that function via PyMongo requires wrapping the function call with placeholder parameters in a Code object and passing in values as a dict:&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;var1 = 1
var2 = 2
result = db.eval(pymongo.code.Code(&#39;add(a, b)&#39;, {&#39;a&#39;: var1, &#39;b&#39;: var2,}))
assert result == 3
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; See [MongoDB dev Mike Dirolf comment][1] to see a much more concise way of executing server-side functions.&lt;/p&gt;

&lt;p&gt;Bearable for simple functions, but having to manually map parameters to values is tiresome and error prone with longer function signatures.&lt;/p&gt;

&lt;p&gt;What I wanted was something more natural like:&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;var1 = 1
var2 = 2
result = db.add(var1, var2)
assert result == 3
&lt;/pre&gt;

&lt;p&gt;I use a simple PyMongo Database object wrapper to make my life easier:&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;import string

from pymongo.code import Code

class ServerSideFunctions(object):
    def __init__(self, db):
        self.db = db

    def func_wrapper(self, func):
        &#39;&#39;&#39;Returns a closure for calling a server-side function.&#39;&#39;&#39;
        params = [] # To keep params ordered
        kwargs = {}
        def server_side_func(*args):
            &#39;&#39;&#39;Calls server side function with positional arguments.&#39;&#39;&#39;
            # Could be removed with better param generating logic
            if len(args) &gt; len(string.letters):
                raise TypeError(&#39;%s() takes at most %d arguments (%d given)&#39;
                        % (func, len(string.letters), len(args)))
            
            # Prepare arguments
            for k, v in zip(string.letters, args):
                kwargs[k] = v
                params.append(k) 

            # Prepare code object
            code = Code(&#39;%s(%s)&#39; % (func, &#39;, &#39;.join(params)), kwargs)
                
            # Return result of server-side function
            return self.db.eval(code)
        return server_side_func

    def __getattr__(self, func):
        &#39;&#39;&#39;Return a closure for calling server-side function named `func`&#39;&#39;&#39;
        return self.func_wrapper(func)

dbjs = ServerSideFunctions(&#39;foo&#39;)
var1 = 1
var2 = 2
result = dbjs.add(var1, var2)
assert result == 3
&lt;/pre&gt;

&lt;p&gt;I&amp;#8217;m tempted to monkey-patch PyMongo&amp;#8217;s Database class to add a ServerSideFunctions instance directly as a js attribute, so then I could drop the confusing &lt;code&gt;dbjs&lt;/code&gt; variable and just use:&lt;/p&gt;

&lt;pre lang=&#34;python&#34;&gt;assert db.js.add(1,2) == 3
&lt;/pre&gt;

&lt;p&gt;If someone knows of a better way to access server-side MongoDB functions from Python, please let me know!&lt;/p&gt;

&lt;p&gt;&lt;small&gt;I modified this code to remove code specific to my project, so please let me know if there are errors.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;[1]: &lt;a href=&#34;http://michael.susens-schurter.com/blog/2010/01/11/making-server-side-mongodb-functions-less-awkward/comment-page-1/#comment-68027&#34;&gt;http://michael.susens-schurter.com/blog/2010/01/11/making-server-side-mongodb-functions-less-awkward/comment-page-1/#comment-68027&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web Developer Contractor Rates</title>
      <link>/2009/11/18/web-developer-contractor-rates/</link>
      <pubDate>Wed, 18 Nov 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/11/18/web-developer-contractor-rates/</guid>
      <description>&lt;p&gt;We just happened* to start chatting in the #pdxdjango IRC channel on Freenode about what the rates web developer contractors charge today, and I wanted to post my experiences after leaving the contractor world a few months ago after 2 years of more or less successful contracting either individually or via &lt;a href=&#34;http://lofiart.com&#34;&gt;Lo-Fi Art&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A really rough table of my rates as a contractor:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Experience&lt;/th&gt;
&lt;th&gt;Rate per hour&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;Entry Level&lt;/td&gt;
&lt;td&gt;$8-20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;Experienced&lt;/td&gt;
&lt;td&gt;$20-65&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;Specialist&lt;/td&gt;
&lt;td&gt;never got here with PHP (thankfully  )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Sysadmin&lt;/td&gt;
&lt;td&gt;Slightly Experienced&lt;/td&gt;
&lt;td&gt;$45&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;Entry Level&lt;/td&gt;
&lt;td&gt;$25-35&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;Experienced&lt;/td&gt;
&lt;td&gt;$35-65&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;Specialist (Django)&lt;/td&gt;
&lt;td&gt;$65-85&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;However, I think I&amp;#8217;ve billed pretty cheaply, especially for Python work. If I had continued in the contracting world I think I would have been aiming for north of &lt;strong&gt;$100/hr for new contracts by the end of 2009&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Important Notes&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All of the experience levels and rates are really rough estimates, please don&amp;#8217;t read too much into it. I just wanted to give people &lt;em&gt;some&lt;/em&gt; idea of what rates are floating around. (I also have a terrible memory, so these numbers could be way off. Mea culpa.)&lt;/li&gt;
&lt;li&gt;The sysadmin job is a career oddity for me and consisted of mostly doing Active Directory / Exchange setup (snuck in a Debian server of course). That being said I still enjoy sysadminish type work today.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experienced&lt;/strong&gt; means you have a few &amp;#8220;serious&amp;#8221; projects under your belt (not the meaingless &amp;#8220;5 years of experience&amp;#8221; so many job descriptions call for).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Specialist&lt;/strong&gt; is a poor term, but I needed someway to describe the shift from &amp;#8220;I&amp;#8217;ll do anything if it&amp;#8217;s PHP or Python&amp;#8221; to &amp;#8220;I&amp;#8217;m a Django&amp;#8221; developer. My guess is that &lt;em&gt;real&lt;/em&gt; specialists (contributors to major projects or popular plugin/module authors) fall into the upper end of this spectrum and can often charge well over $100/hr for highly sought after specialties (Anything + Facebook might be a good example of that right now).&lt;/li&gt;
&lt;li&gt;I started with PHP first (2000-2006), so I was just less experienced in general.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Not only does supply &amp;amp; demand help Python devs fetch a higher rate (reasonable demand, with low supply), but also a Python developer knows how to write code.&lt;/p&gt;

&lt;p&gt;A PHP &amp;#8220;developer&amp;#8221; could just be someone who has setup a few WordPress or Drupal sites and maybe done some theming. I think you&amp;#8217;d be hard pressed to find a web developer who couldn&amp;#8217;t be described as having PHP &amp;#8220;experience.&amp;#8221;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;My entire career in the &amp;#8220;Specialist (Django)&amp;#8221; range was in Portland, OR which has a vibrant web related economy (at least as far as my untrained eye can tell). All other rates fell at least partially into time periods where I lived in Illinois (and not Chicago), so that could account for some of the upward shift in the my rates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;These numbers are also rough estimates because I&amp;#8217;ve done flat per-project billing, retainers, and a variety of other crazy ways of exchanging money for labor. Dollars per hour is still what it all comes down to in the end (like &lt;a href=&#34;http://en.wikipedia.org/wiki/Damage_per_second&#34;&gt;DPS&lt;/a&gt; for you MMORPG freaks).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;So I&amp;#8217;m {ripping off,getting ripped off by} my clients?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;#8217;t know, but I doubt it. If anything my rough estimates should show what an inexact science billing is. It probably varies more on project factors than on the contractor&amp;#8217;s experience.&lt;/p&gt;

&lt;p&gt;Right up until I took my full time job at [YouGov][3] my &lt;em&gt;favorite&lt;/em&gt; client was still paying me at my $35/hr rate. In fact sometimes &lt;strong&gt;I wonder if there might have been an inverse relationship between hourly rate and job satisfaction.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This could be a quirk of me being a pretty neurotic person and therefore feeling more pressure when working at a higher rate. At lower rates I generally worked more hours and spent more time tweaking designs, writing tests, and doing other tasks other than putting my head down and coding. Thus at the end of the day, the more hours I worked on projects I liked, the less money I made (relative to working fewer hours on less enjoyable projects).&lt;/p&gt;

&lt;p&gt;&lt;small&gt;* Ok, so it looks like I brought it up&amp;#8230; but I&amp;#8217;d like to think it spawned some good discussion.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Left off the Python category as that gets syndicated on Unofficial Planet Python, and I don&amp;#8217;t think this post is high enough quality to deserve that. &lt;img src=&#34;http://localhost/wp-includes/images/smilies/simple-smile.png&#34; alt=&#34;:)&#34; class=&#34;wp-smiley&#34; style=&#34;height: 1em; max-height: 1em;&#34; /&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;[3]: &lt;a href=&#34;http://www.yougov.com&#34;&gt;http://www.yougov.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 9.10 on a Thinkpad T400</title>
      <link>/2009/11/11/ubuntu-9-10-on-a-thinkpad-t400/</link>
      <pubDate>Thu, 12 Nov 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/11/11/ubuntu-9-10-on-a-thinkpad-t400/</guid>
      <description>&lt;p&gt;I upgraded from Ubuntu 9.04 to &lt;a href=&#34;http://www.ubuntu.com/products/whatisubuntu/910features&#34;&gt;9.10&lt;/a&gt; on my Lenovo Thinkpad T400 about a week ago, and thought I&amp;#8217;d write down some of my impressions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Good news&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ATI graphics card with proprietary binary driver &amp;#8211; just works (much better than 9.04 as well).&lt;/li&gt;
&lt;li&gt;Suspend &amp;amp; hibernate work flawlessly.&lt;/li&gt;
&lt;li&gt;Boots fast.&lt;/li&gt;
&lt;li&gt;Upgrade worked flawlessly.&lt;/li&gt;
&lt;li&gt;Sound (better volume panel!), wifi, USB, network printer, bluetooth (option to turn it on/off!), webcam, etc. all still work.&lt;/li&gt;
&lt;li&gt;New theme is nice.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I manually &lt;a href=&#34;http://ext4.wiki.kernel.org/index.php/Ext4_Howto#Converting_an_ext3_filesystem_to_ext4&#34;&gt;upgraded my filesystem to ext4&lt;/a&gt; and &lt;a href=&#34;https://wiki.ubuntu.com/KernelTeam/Grub2Testing&#34;&gt;grub from version 1 to 2&lt;/a&gt;. It was a bit scary but worked out fine. Can&amp;#8217;t really feel a difference, but my laptop is mainly a dumb terminal for running web browsers and ssh. &lt;/ul&gt;
&lt;strong&gt;&lt;a href=&#34;http://live.gnome.org/Empathy&#34;&gt;Empathy&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ubuntu replaced Pidgin with Empathy as the default IM client in Ubuntu 9.10. I think because Empathy supports voice/video chat and Pidgin doesn&amp;#8217;t? I&amp;#8217;ve used video chat once in my life and that was through Skype on Linux. It worked great, but it&amp;#8217;s really not a feature I care about.&lt;/p&gt;

&lt;p&gt;So for someone like me who doesn&amp;#8217;t care about Empathy&amp;#8217;s singular advantage over Pidgin, Empathy is a major step backward. At first it was extremely crashy, but a recent update seems to have fixed that. However, now it mysteriously loses messages. I&amp;#8217;m a very light IM user, but it would start silently missing messages a few hours into the day every day.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve switched back to Pidgin and couldn&amp;#8217;t be happier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Message Notification applet deal&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Empathy integrates with the message notification applet deal along with Evolution. Other apps may as well, but evidently I don&amp;#8217;t use any of them. My top panel is 75% whitespace, so the singular benefit of Ubuntu&amp;#8217;s consolidated message notification applet was completely lost on me.&lt;/p&gt;

&lt;p&gt;So much like Empathy, I removed this specialized applet as well. I&amp;#8217;m much happier with per-application icons anyway and fail to see what the benefit of consolidating them is (unless you have a really cramped top panel).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;New Theme&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I like it, but then I installed Chromium. Now the bold window titles and expansive title bars in Metacity look bulky and antiquated. Gnome really needs to evolve their window manager and default UI. Chrome is an excellent example of how to design a compact, minimal, yet still pleasant and intuitive user interface.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://wiki.ubuntu.com/SoftwareCenter&#34;&gt;Ubuntu Software Center&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What a curious little replacement for the old Add/Remove Applications program. I think I see the direction they&amp;#8217;re headed, but it definitely feels like rolled out a beta program to replace a perfectly functional and stable one.&lt;/p&gt;

&lt;p&gt;The left pane with expansive whitespace and 2 options &lt;em&gt;hints&lt;/em&gt; that there might be more categories in the future, but right now it just looks like a mistake. Like maybe something isn&amp;#8217;t working properly, and I&amp;#8217;m not seeing all the options I should see.&lt;/p&gt;

&lt;p&gt;At any rate, I hope Ubuntu adds an App Store that even includes evil proprietary software. I&amp;#8217;d love to be able to plunk down a few bucks for a game like [Braid][6] directly from Ubuntu Software Center. That&amp;#8217;d be great! Maybe Canonical could even pocket a few pennies and start making Linux-on-the-desktop profitable. Now I&amp;#8217;m just dreaming though&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bottom Line&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;9.10 is a solid and safe upgrade for any users of previous versions. Not sure there&amp;#8217;s anything new to win over users from OS X or Windows though.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[6]: &lt;a href=&#34;http://braid-game.com/&#34;&gt;http://braid-game.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lxml vs. ElementTree</title>
      <link>/2009/10/14/lxml-vs-elementtree/</link>
      <pubDate>Wed, 14 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/10/14/lxml-vs-elementtree/</guid>
      <description>&lt;p&gt;While lxml has some &lt;a href=&#34;http://codespeak.net/lxml/performance.html&#34;&gt;excellent benchmarks about the speed of lxml.etree vs. ElementTree&lt;/a&gt;, I wanted to run some tests that were as close as possible to my own use case (fairly simple multi-megabyte XML files).&lt;/p&gt;

&lt;p&gt;Here are the results of my little test script [lxml-v-etree.py]&lt;a href=&#34;times are in milliseconds&#34;&gt;2&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;name           generate | tostring | total | write | parse | find | total
------------------------+----------+-------+-------+-------+------+------
xml.cElementTree    132 |   2430   |  2562 |  2433 |   158 |   58 |   216
xml.cElementTree    112 |   2384   |  2497 |  2387 |   158 |   25 |   183
xml.cElementTree    113 |   2393   |  2507 |  2396 |   161 |   25 |   187
xml.ElementTree     591 |   2571   |  3163 |  2574 |  3613 |   25 |  3638
xml.ElementTree     619 |   2567   |  3187 |  2570 |  3589 |   55 |  3644
xml.ElementTree     609 |   2578   |  3188 |  2581 |  3564 |   55 |  3619
lxml                333 |     75   |   409 |    82 |   200 |    0 |   201
lxml                355 |     93   |   448 |    95 |   182 |   32 |   214
lxml                310 |     94   |   404 |    96 |   156 |   56 |   213
------------------------+----------+-------+-------+-------+------+------
name           generate | tostring | total | write | parse | find | total
------------------------+----------+-------+-------+-------+------+------
&lt;/pre&gt;

&lt;p&gt;Note that the first &amp;#8220;total&amp;#8221; is &amp;#8220;generate + tostring&amp;#8221; while the second &amp;#8220;total&amp;#8221; is for the 2 parsing related tests (previous 2 columns summed).&lt;/p&gt;

&lt;p&gt;My parsing tests are basically &amp;#8220;etree.parse&amp;#8221; and then running &amp;#8220;Element.getchildren()&amp;#8221; 3 times, which is ridiculously simplistic and should probably be ignored. My writing tests are far more thorough/realistic.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;m running Python 2.6.2 with lxml 2.1.5 and libxml2 2.6.32 on Ubuntu 9.04 x86_64.&lt;/p&gt;

&lt;p&gt;[2]: /files/lxml-v-etree.py-remove-me&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Chrome Frame</title>
      <link>/2009/09/22/google-chrome-frame/</link>
      <pubDate>Tue, 22 Sep 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/09/22/google-chrome-frame/</guid>
      <description>&lt;p&gt;I maintain a web application that must support Internet Explorer 6, so I was delighted to hear about [Google Chrome Frame][1].&lt;/p&gt;

&lt;p&gt;Unfortunately their warnings of its alpha status seem to be well founded. The 2 show-stoppers I ran into fairly quickly were:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Flash is difficult to install. (Tip: Try visiting: &lt;a href=&#34;cf:http://www.adobe.com/software/flash/about/&#34;&gt;cf:http://www.adobe.com/software/flash/about/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;The Location bar did not always change to reflect the current page.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;#8217;ll definitely be following this project closely as it may allow corporate users stuck on IE to use a different browser relatively easily.&lt;/p&gt;

&lt;p&gt;[1]: &lt;a href=&#34;http://code.google.com/chrome/chromeframe/&#34;&gt;http://code.google.com/chrome/chromeframe/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python Packaging Talk</title>
      <link>/2009/09/09/python-packaging-talk/</link>
      <pubDate>Wed, 09 Sep 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/09/09/python-packaging-talk/</guid>
      <description>&lt;p&gt;I gave a talk at &lt;a href=&#34;http://pdxpython.org/&#34;&gt;PDX Python&lt;/a&gt; last night on Python Packaging. It&amp;#8217;s just an overview and introduction completely lacking in any practical examples.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/files/packaging.odp&#34;&gt;Python Packaging slides (ODP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/files/packaging-2.pdf&#34;&gt;Python Packaging slides (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;Let me know if the ODP source is messed up. OpenOffice.org liked randomly losing background images and forgetting other formatting.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;So as penance I quick hacked up a silly little command line utility and uploaded it to PyPI to serve as a simple packaging example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pypi.python.org/pypi/whereampy&#34;&gt;whereampy on PyPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://bitbucket.org/schmichael/whereampy/&#34;&gt;whereampy on bitbucket&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;#8217;d be nice to add some more advanced features like test running, including package data, and building C extensions. If you feel adventurous please &lt;a href=&#34;http://bitbucket.org/schmichael/whereampy/fork/&#34;&gt;fork&lt;/a&gt; it and send me a &lt;a href=&#34;http://bitbucket.org/schmichael/whereampy/pull/&#34;&gt;pull request&lt;/a&gt; on BitBucket.&lt;/p&gt;

&lt;p&gt;Thanks to everyone who came to PDX Python last night! Especially &lt;a href=&#34;http://lucumr.pocoo.org/&#34;&gt;Armin Ronacher&lt;/a&gt; who was able to clarify and elaborate on a number of different distutils/setuptools topics!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Just spotted &lt;a href=&#34;http://tarekziade.wordpress.com/2009/09/12/static-metadata-for-distutils/&#34;&gt;an excellent post on distutils and setuptools by Tarek Ziad.&lt;/a&gt; Make sure to [read his blog if you&amp;#8217;re interested in packaging in Python.][10]&lt;/p&gt;

&lt;p&gt;[10]: &lt;a href=&#34;http://tarekziade.wordpress.com/&#34;&gt;http://tarekziade.wordpress.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Switched tc-rest to webob</title>
      <link>/2009/08/10/switched-tc-est-to-webob/</link>
      <pubDate>Tue, 11 Aug 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/08/10/switched-tc-est-to-webob/</guid>
      <description>&lt;p&gt;Small update on my toy tc-rest project: I switched to using &lt;a href=&#34;http://pythonpaste.org/webob/&#34;&gt;WebOb&lt;/a&gt; for creating HTTP Request and Response objects. Cleaned up the code a bit, but a real dispatcher is what&amp;#8217;s needed to really remove the cruft.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;m anxious to extend the API and add features, but I have no clue when I&amp;#8217;ll have time to touch it again. In the mean time I&amp;#8217;ve [pushed tc-rest to bitbucket.org if you want to take a look][2].&lt;/p&gt;

&lt;p&gt;[2]: &lt;a href=&#34;http://bitbucket.org/schmichael/tc-rest/overview/&#34;&gt;http://bitbucket.org/schmichael/tc-rest/overview/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>